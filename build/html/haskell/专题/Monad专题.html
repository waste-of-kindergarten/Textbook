<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN">
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Monad专题 &mdash; TextBook v0.1 文档</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css" />
      <link rel="stylesheet" type="text/css" href="../../_static/dark_mode_css/general.css" />
      <link rel="stylesheet" type="text/css" href="../../_static/dark_mode_css/dark.css" />

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/sphinx_highlight.js"></script>
        <script src="../../_static/translations.js"></script>
        <script src="../../_static/dark_mode_js/default_dark.js"></script>
        <script src="../../_static/dark_mode_js/theme_switcher.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="索引" href="../../genindex.html" />
    <link rel="search" title="搜索" href="../../search.html" />
    <link rel="next" title="资源" href="../%E8%B5%84%E6%BA%90.html" />
    <link rel="prev" title="函子专题" href="%E5%87%BD%E5%AD%90%E4%B8%93%E9%A2%98.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            TextBook
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="搜索文档" aria-label="搜索文档" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="导航菜单">
              <p class="caption" role="heading"><span class="caption-text">目录:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">Haskell TextBook</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../Haskell%20%E5%AE%89%E8%A3%85%E4%B8%8E%E5%85%A5%E9%97%A8.html">Haskell 安装与入门</a></li>
<li class="toctree-l2"><a class="reference internal" href="../%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%87%BD%E6%95%B0.html">数据类型与函数</a></li>
<li class="toctree-l2"><a class="reference internal" href="../%E8%A1%A8%E8%BE%BE%E5%BC%8F.html">表达式</a></li>
<li class="toctree-l2"><a class="reference internal" href="../%E9%80%92%E5%BD%92%E4%B8%8E%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0.html">递归与高阶函数</a></li>
<li class="toctree-l2"><a class="reference internal" href="../%E7%B1%BB%E5%9E%8B%E7%B1%BB.html">类型类</a></li>
<li class="toctree-l2"><a class="reference internal" href="%E5%87%BD%E5%AD%90%E4%B8%93%E9%A2%98.html">函子专题</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Monad专题</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id1"><code class="docutils literal notranslate"><span class="pre">Monad</span></code>介绍</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id2">常见的 monad</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#identity-monad"><code class="docutils literal notranslate"><span class="pre">Identity</span></code> monad</a></li>
<li class="toctree-l4"><a class="reference internal" href="#maybe-monad"><code class="docutils literal notranslate"><span class="pre">Maybe</span></code> monad</a></li>
<li class="toctree-l4"><a class="reference internal" href="#list-monad"><code class="docutils literal notranslate"><span class="pre">List</span></code> monad</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id3">更多 monad</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#do">do-标记</a></li>
<li class="toctree-l4"><a class="reference internal" href="#io-monad"><code class="docutils literal notranslate"><span class="pre">IO</span></code> monad</a></li>
<li class="toctree-l4"><a class="reference internal" href="#state-monad"><code class="docutils literal notranslate"><span class="pre">State</span></code> monad</a></li>
<li class="toctree-l4"><a class="reference internal" href="#reader-monad"><code class="docutils literal notranslate"><span class="pre">Reader</span></code> monad</a></li>
<li class="toctree-l4"><a class="reference internal" href="#writer-monad"><code class="docutils literal notranslate"><span class="pre">Writer</span></code> monad</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#monad-monadplus">增强Monad <code class="docutils literal notranslate"><span class="pre">MonadPlus</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#id4">monad 转换器</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#identityt-monad">IdentityT monad 转换器</a></li>
<li class="toctree-l4"><a class="reference internal" href="#monad-monadtrans">monad 提升 <code class="docutils literal notranslate"><span class="pre">MonadTrans</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#io-monad-monadio">IO monad 提升 <code class="docutils literal notranslate"><span class="pre">MonadIO</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#id5">多次 monad 提升</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id6">更多 monad 转换器</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../%E8%B5%84%E6%BA%90.html">资源</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="移动版导航菜单" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">TextBook</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="页面导航">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Haskell TextBook</a></li>
      <li class="breadcrumb-item active">Monad专题</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/haskell/专题/Monad专题.md.txt" rel="nofollow"> 查看页面源码</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="monad">
<h1>Monad专题<a class="headerlink" href="#monad" title="此标题的永久链接"></a></h1>
<p>在<a class="reference internal" href="%E5%87%BD%E5%AD%90%E4%B8%93%E9%A2%98.html"><span class="doc">函子专题</span></a>中已经简要介绍了<code class="docutils literal notranslate"><span class="pre">Monad</span></code>类型类的定义与用法。本章将针对<code class="docutils literal notranslate"><span class="pre">Monad</span></code>展开，讲解有关<code class="docutils literal notranslate"><span class="pre">Monad</span></code>更多有关特性与用法。</p>
<section id="id1">
<h2><code class="docutils literal notranslate"><span class="pre">Monad</span></code>介绍<a class="headerlink" href="#id1" title="此标题的永久链接"></a></h2>
<p>在Haskell中，monad经常被认为是计算的抽象描述符,本质上这些描述符可以进行组合，使用较小的表达式构建更大的表达式<a class="reference external" href="#ref1">[1]</a>。Monad可以作为各种数据或控制结构的标准编程接口<a class="reference external" href="#ref2">[2]</a>。</p>
<blockquote>
<div><p>补充： 这里的表达式有时也被称为“动作”(actions)</p>
</div></blockquote>
<p>monad具有三个属性，这些属性使其非常高效有用：</p>
<ul class="simple">
<li><p>模块化： monad允许计算由更简单的计算组合而合成，并将组合策略与正在执行的实际计算分开。</p></li>
<li><p>灵活性： monad使得其函数式程序相比等价的不适用单子书写的程序更具有适应性。monad将计算策略集中到一个位置，而无需分散在整个程序中。</p></li>
<li><p>隔离性：monad可以用于创建命令式计算结构，这些结构与程序主体保持安全的隔离。<a class="reference external" href="#ref2">[2]</a></p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">Monad</span></code>类型类定义如下：</p>
<div class="highlight-hs notranslate"><div class="highlight"><pre><span></span><span class="kr">class</span><span class="w"> </span><span class="kt">Applicative</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Monad</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span>
<span class="w">    </span><span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">b</span><span class="w"> </span>
<span class="w">    </span><span class="p">(</span><span class="o">&gt;&gt;</span><span class="p">)</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">b</span><span class="w"> </span>
<span class="w">    </span><span class="n">return</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">a</span>
<span class="w">    </span><span class="n">fail</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">String</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">a</span>
<span class="w">    </span><span class="cm">{-# MINIMAL (&gt;&gt;=) #-}</span>
</pre></div>
</div>
<p>通过定义，我们知道一个monad前提必须是一个应用函子，然而仅仅实现了某个类型的单子类型类的实例并不能保证其为真正monad。在此基础上，还应当满足以下单子律：</p>
<ul class="simple">
<li><p>左单位元： <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">a</span> <span class="pre">&gt;&gt;=</span> <span class="pre">k</span> <span class="pre">=</span> <span class="pre">k</span> <span class="pre">a</span></code></p></li>
<li><p>右单位元： <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">&gt;&gt;=</span> <span class="pre">return</span> <span class="pre">=</span> <span class="pre">m</span></code></p></li>
<li><p>结合律：<code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">&gt;&gt;=</span> <span class="pre">(\x</span> <span class="pre">-&gt;</span> <span class="pre">k</span> <span class="pre">x</span> <span class="pre">&gt;&gt;=</span> <span class="pre">h)</span> <span class="pre">=</span> <span class="pre">(m</span> <span class="pre">&gt;&gt;=</span> <span class="pre">k)</span> <span class="pre">&gt;&gt;=</span> <span class="pre">h</span></code></p></li>
</ul>
</section>
<section id="id2">
<h2>常见的 monad<a class="headerlink" href="#id2" title="此标题的永久链接"></a></h2>
<p>下面依次介绍几个Haskell内置的 monad，并验证其确实满足单子律。</p>
<section id="identity-monad">
<h3><code class="docutils literal notranslate"><span class="pre">Identity</span></code> monad<a class="headerlink" href="#identity-monad" title="此标题的永久链接"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">Identity</span></code> monad 作为最简单的具有单子性质的类型，它仅仅定义了一个容器，以容纳某个类型的值。其定义如下：</p>
<div class="highlight-hs notranslate"><div class="highlight"><pre><span></span><span class="kr">newtype</span><span class="w"> </span><span class="kt">Identity</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Idnetity</span><span class="w"> </span><span class="p">{</span><span class="n">runIdentity</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">a</span><span class="p">}</span>

<span class="kr">instance</span><span class="w"> </span><span class="kt">Monad</span><span class="w"> </span><span class="kt">Identity</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span>
<span class="w">    </span><span class="kt">Identity</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">&gt;&gt;=</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">m</span><span class="w"> </span>
</pre></div>
</div>
<blockquote>
<div><p>提示：<code class="docutils literal notranslate"><span class="pre">Identity</span></code>可从<code class="docutils literal notranslate"><span class="pre">Control.Monad.Identity</span></code>导入，或者从定义处<code class="docutils literal notranslate"><span class="pre">Data.Functor.Identity</span></code>导入</p>
</div></blockquote>
<p>下面证明其满足单子律。</p>
<p>对于左单位元，有：</p>
<div class="highlight-hs notranslate"><div class="highlight"><pre><span></span>左边 = return a &gt;&gt;= k 
= Identity a &gt;&gt;= k 
= k a = 右边
</pre></div>
</div>
<p>对于右单位元，令<code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">=</span> <span class="pre">Identity</span> <span class="pre">a</span></code>：</p>
<div class="highlight-hs notranslate"><div class="highlight"><pre><span></span>左边 = m &gt;&gt;= return 
= Identity a &gt;&gt;= return 
= return a
= Identity a = m = 右边
</pre></div>
</div>
<p>对于结合律，仍然令<code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">=</span> <span class="pre">Identity</span> <span class="pre">a</span></code>:</p>
<div class="highlight-hs notranslate"><div class="highlight"><pre><span></span>左边 = m &gt;&gt;= (\x -&gt; k x &gt;&gt;= h)
= Identity a &gt;&gt;= (\x -&gt; k x &gt;&gt;= h)
= k a &gt;&gt;= h
= (Identity a &gt;&gt;= k) &gt;&gt;= h
= (m &gt;&gt;= k) &gt;&gt;= h = 右边
</pre></div>
</div>
<p>因此，<code class="docutils literal notranslate"><span class="pre">Identity</span></code>满足单子律。</p>
</section>
<section id="maybe-monad">
<h3><code class="docutils literal notranslate"><span class="pre">Maybe</span></code> monad<a class="headerlink" href="#maybe-monad" title="此标题的永久链接"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">Maybe</span></code> monad定义如下：</p>
<div class="highlight-hs notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span><span class="w"> </span><span class="kt">Monad</span><span class="w"> </span><span class="kt">Maybe</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span>
<span class="w">    </span><span class="kt">Nothing</span><span class="w"> </span><span class="o">&gt;&gt;=</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Nothing</span>
<span class="w">    </span><span class="p">(</span><span class="kt">Just</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;=</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="w"> </span>
</pre></div>
</div>
<p>下面我们来验证其满足单子律。</p>
<p>对于左单位元，要证<code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">a</span> <span class="pre">&gt;&gt;=</span> <span class="pre">k</span> <span class="pre">=</span> <span class="pre">k</span> <span class="pre">a</span></code>，其中<code class="docutils literal notranslate"><span class="pre">k</span></code>的类型为<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">Maybe</span> <span class="pre">b</span></code>。</p>
<div class="highlight-hs notranslate"><div class="highlight"><pre><span></span>左边 = return a &gt;&gt;= k 
= Just a &gt;&gt;= k 
= k a = 右边
</pre></div>
</div>
<p>对于右单位元，要证<code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">&gt;&gt;=</span> <span class="pre">return</span> <span class="pre">=</span> <span class="pre">m</span></code>，其中<code class="docutils literal notranslate"><span class="pre">m</span></code>的类型为<code class="docutils literal notranslate"><span class="pre">Maybe</span> <span class="pre">a</span></code>。</p>
<div class="highlight-hs notranslate"><div class="highlight"><pre><span></span>当 m = Nothing 时：

左边 = m &gt;&gt;= return 
= Nothing &gt;&gt;= return 
= Nothing = m = 右边

当 m = Just a 时：

左边 = m &gt;&gt;= return 
= Just a &gt;&gt;= return 
= return a 
= Just a = m = 右边
</pre></div>
</div>
<p>对于结合律，要证<code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">&gt;&gt;=</span> <span class="pre">(\x</span> <span class="pre">-&gt;</span> <span class="pre">k</span> <span class="pre">x</span> <span class="pre">&gt;&gt;=</span> <span class="pre">h)</span> <span class="pre">=</span> <span class="pre">(m</span> <span class="pre">&gt;&gt;=</span> <span class="pre">k)</span> <span class="pre">&gt;&gt;=</span> <span class="pre">h</span></code>，其中<code class="docutils literal notranslate"><span class="pre">m</span></code>的类型为<code class="docutils literal notranslate"><span class="pre">Maybe</span> <span class="pre">a</span></code>,<code class="docutils literal notranslate"><span class="pre">k</span></code>的类型为<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">Maybe</span> <span class="pre">b</span></code>,<code class="docutils literal notranslate"><span class="pre">h</span></code>的类型为<code class="docutils literal notranslate"><span class="pre">b</span> <span class="pre">-&gt;</span> <span class="pre">Maybe</span> <span class="pre">c</span></code>。</p>
<div class="highlight-hs notranslate"><div class="highlight"><pre><span></span>当 m = Nothing 时：

左边 = m &gt;&gt;= (\x -&gt; k x &gt;&gt;= h)
= Nothing &gt;&gt;= (\x -&gt; k x &gt;&gt;= h)
= Nothing 
= Nothing &gt;&gt;= h
= (Nothing &gt;&gt;= k) &gt;&gt;= h 
= (m &gt;&gt;= k) &gt;&gt;= h
= 右边

当 m = Just a 时：

左边 = m &gt;&gt;= (\x -&gt; k x &gt;&gt;= h)
= Just a &gt;&gt;= (\x -&gt; k x &gt;&gt;= h)
= k a &gt;&gt;= h
= (Just a &gt;&gt;= k) &gt;&gt;= h
= (m &gt;&gt;= k) &gt;&gt;= h
= 右边
</pre></div>
</div>
<p>综上，<code class="docutils literal notranslate"><span class="pre">Maybe</span></code>满足成为monad的条件。</p>
<p>最后，我们给出一个示例：假设我们拥有若干字符串，我们首先需要将其合并后，并计算其中非字母字符的数量。</p>
<div class="highlight-hs notranslate"><div class="highlight"><pre><span></span><span class="c1">-- code&#39;2.hs</span>
<span class="kr">import</span><span class="w"> </span><span class="nn">Data.Char</span><span class="p">(</span><span class="n">isAlpha</span><span class="p">)</span>

<span class="nf">string1</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Just</span><span class="w"> </span><span class="s">&quot;My name is &quot;</span>

<span class="nf">string2</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Just</span><span class="w"> </span><span class="s">&quot;L fried.&quot;</span>
<span class="c1">-- just joking (Alfred)</span>
<span class="nf">string3</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Just</span><span class="w"> </span><span class="s">&quot;The textbook seems a mess 2 readers !&quot;</span>

<span class="nf">maybeMonadDemo</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Maybe</span><span class="w"> </span><span class="kt">Int</span>
<span class="nf">maybeMonadDemo</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span>
<span class="w">    </span><span class="n">string1</span><span class="w"> </span><span class="o">&gt;&gt;=</span><span class="w"> </span><span class="nf">\</span><span class="n">x</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span>
<span class="w">        </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;$&gt;</span><span class="w"> </span><span class="n">string2</span><span class="w"> </span><span class="o">&gt;&gt;=</span>
<span class="w">            </span><span class="nf">\</span><span class="n">y</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span>
<span class="w">                </span><span class="p">(</span><span class="n">y</span><span class="w"> </span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;$&gt;</span><span class="w"> </span><span class="n">string3</span><span class="w"> </span><span class="o">&gt;&gt;=</span>
<span class="w">                    </span><span class="nf">\</span><span class="n">z</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span>
<span class="w">                        </span><span class="kt">Just</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">foldr</span><span class="w"> </span><span class="p">(</span><span class="o">+</span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">(((</span><span class="nf">\</span><span class="n">x</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kr">if</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="kr">else</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">isAlpha</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;$&gt;</span><span class="w"> </span><span class="n">z</span><span class="p">))</span>

<span class="c1">-- 等效于</span>
<span class="nf">maybeMonadDemo&#39;</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Maybe</span><span class="w"> </span><span class="kt">Int</span>
<span class="nf">maybeMonadDemo&#39;</span><span class="w"> </span><span class="ow">=</span>
<span class="w">    </span><span class="n">string1</span><span class="w"> </span><span class="o">&gt;&gt;=</span><span class="w"> </span><span class="nf">\</span><span class="n">x</span><span class="w"> </span><span class="ow">-&gt;</span>
<span class="w">        </span><span class="n">string2</span><span class="w"> </span><span class="o">&gt;&gt;=</span><span class="w"> </span><span class="p">(</span>
<span class="w">            </span><span class="nf">\</span><span class="n">y</span><span class="w"> </span><span class="ow">-&gt;</span>
<span class="w">                </span><span class="n">string3</span><span class="w"> </span><span class="o">&gt;&gt;=</span><span class="w"> </span><span class="p">(</span>
<span class="w">                    </span><span class="nf">\</span><span class="n">z</span><span class="w"> </span><span class="ow">-&gt;</span>
<span class="w">                        </span><span class="kt">Just</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">foldr</span><span class="w"> </span><span class="p">(</span><span class="o">+</span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">(((</span><span class="nf">\</span><span class="n">x</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kr">if</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="kr">else</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">isAlpha</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;$&gt;</span><span class="w"> </span><span class="n">z</span><span class="p">)))</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="p">(</span><span class="n">y</span><span class="w"> </span><span class="o">++</span><span class="p">))</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">++</span><span class="p">)</span>
</pre></div>
</div>
<p>尝试在GHCi中运行查看结果：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>Prelude&gt;<span class="w"> </span>:load<span class="w"> </span>code<span class="s1">&#39;2.hs</span>
<span class="s1">[1 of 1] Compiling Main             ( code&#39;</span><span class="m">2</span>.hs,<span class="w"> </span>interpreted<span class="w"> </span><span class="o">)</span>
Ok,<span class="w"> </span>one<span class="w"> </span>module<span class="w"> </span>loaded.
Prelude&gt;<span class="w"> </span>maybeMonadDemo
Just<span class="w"> </span><span class="m">14</span>
</pre></div>
</div>
</section>
<section id="list-monad">
<h3><code class="docutils literal notranslate"><span class="pre">List</span></code> monad<a class="headerlink" href="#list-monad" title="此标题的永久链接"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">List</span></code> monad 定义如下：</p>
<div class="highlight-hs notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span><span class="w"> </span><span class="kt">Monad</span><span class="w"> </span><span class="kt">[]</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span>
<span class="w">    </span><span class="n">xs</span><span class="w"> </span><span class="o">&gt;&gt;=</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">concatMap</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">xs</span>
</pre></div>
</div>
<p>其中<code class="docutils literal notranslate"><span class="pre">concatMap</span></code>函数类型为<code class="docutils literal notranslate"><span class="pre">Foldable</span> <span class="pre">t</span> <span class="pre">=&gt;</span> <span class="pre">(a</span> <span class="pre">-&gt;</span> <span class="pre">[b])</span> <span class="pre">-&gt;</span> <span class="pre">t</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">[b]</span></code>，当<code class="docutils literal notranslate"><span class="pre">xs</span></code>有多于一个元素时，该函数会将<code class="docutils literal notranslate"><span class="pre">f</span></code>对每个元素映射的结果进行拼接。</p>
<p>下面我们来验证其满足单子律。</p>
<p>对于左单位元，要证<code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">a</span> <span class="pre">&gt;&gt;=</span> <span class="pre">k</span> <span class="pre">=</span> <span class="pre">k</span> <span class="pre">a</span></code>，其中<code class="docutils literal notranslate"><span class="pre">k</span></code>的类型为<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">[b]</span></code>。</p>
<div class="highlight-hs notranslate"><div class="highlight"><pre><span></span>左边 = return a &gt;&gt;= k 
= [a] &gt;&gt;= k 
= k a = 右边
</pre></div>
</div>
<p>对于右单位元，要证<code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">&gt;&gt;=</span> <span class="pre">return</span> <span class="pre">=</span> <span class="pre">m</span></code>，其中<code class="docutils literal notranslate"><span class="pre">m</span></code>的类型为<code class="docutils literal notranslate"><span class="pre">[a]</span></code>。</p>
<div class="highlight-hs notranslate"><div class="highlight"><pre><span></span>当 m = [] 时

左边 = m &gt;&gt;= return 
= concatMap return m 
= concatMap return []
= [] = m = 右边

当 m = (x:xs) 时，假设对于xs，右单位元成立，即`m1 &gt;&gt;= return = concatMap return xs = m1`成立

左边 = m &gt;&gt;= return 
= concatMap return m 
= concatMap return (x:xs)
= return x ++ concatMap return xs
= [x] ++ concatMap return xs 
= [x] ++ (m1 &gt;&gt;= return)
= [x] ++ xs -- 根据归纳假设
= x:xs = m = 右边
</pre></div>
</div>
<p>对于结合律，要证<code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">&gt;&gt;=</span> <span class="pre">(\x</span> <span class="pre">-&gt;</span> <span class="pre">k</span> <span class="pre">x</span> <span class="pre">&gt;&gt;=</span> <span class="pre">h)</span> <span class="pre">=</span> <span class="pre">(m</span> <span class="pre">&gt;&gt;=</span> <span class="pre">k)</span> <span class="pre">&gt;&gt;=</span> <span class="pre">h</span></code>，其中<code class="docutils literal notranslate"><span class="pre">m</span></code>的类型为<code class="docutils literal notranslate"><span class="pre">[a]</span></code>，<code class="docutils literal notranslate"><span class="pre">k</span></code>的类型为<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">[b]</span></code>，<code class="docutils literal notranslate"><span class="pre">h</span></code>的类型为<code class="docutils literal notranslate"><span class="pre">b</span> <span class="pre">-&gt;</span> <span class="pre">[c]</span></code>。</p>
<div class="highlight-hs notranslate"><div class="highlight"><pre><span></span>当 m = [] 时

左边 = m &gt;&gt;= (\x -&gt; k x &gt;&gt;= h)
= concatMap (\x -&gt; k x &gt;&gt;= h) m
= concatMap (\x -&gt; k x &gt;&gt;= h) []
= []
= [] &gt;&gt;= h
= ([] &gt;&gt;= k) &gt;&gt;= h
= (m &gt;&gt;= k) &gt;&gt;= h = 右边

当 m = (x:xs) 时，假设结合律对xs成立，即`xs &gt;&gt;= (\x -&gt; k x &gt;&gt;= h) = (m1 &gt;&gt;= k) &gt;&gt;= h`成立

左边 = m &gt;&gt;= (\x -&gt; k x &gt;&gt;= h)
= concatMap (\x -&gt; k x &gt;&gt;= h) m 
= concatMap (\x -&gt; k x &gt;&gt;= h) (x:xs)
= (k x &gt;&gt;= h) ++ (concatMap (\x -&gt; k x &gt;&gt;= h) xs)
= (k x &gt;&gt;= h) ++ (xs &gt;&gt;= (\x -&gt; k x &gt;&gt;= h))
= (k x &gt;&gt;= h) ++ ((m1 &gt;&gt;= k) &gt;&gt;= h)
= (([x] &gt;&gt;= k) &gt;&gt;= h) ++ ((m1 &gt;&gt;= k) &gt;&gt;= h)
= concatMap h ([x] &gt;&gt;= k) ++ concatMap h (m1 &gt;&gt;= k)
= concatMap h (([x] &gt;&gt;= k) ++ (m1 &gt;&gt;= k)) -- 分配律
= concatMap h ((concatMap k [x]) ++ (concatMap k xs))
= concatMap h (concatMap k ([x] ++ xs)) -- 分配律
= concatMap h (concatMap k (x:xs)) 
= concatMap h (m &gt;&gt;= k)
= (m &gt;&gt;= k) &gt;&gt;= h = 右边
</pre></div>
</div>
<p>这里需要证明的一点是<code class="docutils literal notranslate"><span class="pre">concatMap</span> <span class="pre">_</span></code>和<code class="docutils literal notranslate"><span class="pre">++</span></code>是满足分配律的，即<code class="docutils literal notranslate"><span class="pre">concatMap</span> <span class="pre">f</span> <span class="pre">l1</span> <span class="pre">++</span> <span class="pre">concatMap</span> <span class="pre">f</span> <span class="pre">l2</span> <span class="pre">=</span> <span class="pre">concatMap</span> <span class="pre">f</span> <span class="pre">(l1</span> <span class="pre">++</span> <span class="pre">l2)</span></code>成立。</p>
<div class="highlight-hs notranslate"><div class="highlight"><pre><span></span>当 l1 = [] 时

concatMap f l1 ++ concatMap f l2 
= concatMap f [] ++ concatMap f l2 
= [] ++ concatMap f l2
= concatMap f l2
= concatMap f ([] ++ l2)
= concatMap f (l1 ++ l2)

当 l1 == (x:xs) 时，假设分配律对长度不大于xs的列表均成立

concatMap f l1 ++ concatMap f l2
= concatMap f (x:xs) ++ concatMap f l2
= concatMap f (x:xs) ++ concatMap f l2 
= concatMap f [x] ++ concatMap f xs ++ concatMap f l2 -- 归纳假设
= concatMap f [x] ++ (concatMap f xs ++ conacatMap f l2) -- 结合律 (列表满足半群结构，其中二元运算为拼接操作)
= concatMap f [x] ++ concatMap f (xs ++ l2)
= concatMap f ([x] ++ xs ++ l2) -- 归纳假设
= concatMap f ((x:xs) ++ l2) -- 结合律
= concatMap f (l1 ++ l2)
</pre></div>
</div>
<p>综上，列表满足成为monad条件。</p>
</section>
</section>
<section id="id3">
<h2>更多 monad<a class="headerlink" href="#id3" title="此标题的永久链接"></a></h2>
<p>接下来我们了解更多的monad，我们将侧重点放在这些monad的功能和使用上。</p>
<section id="do">
<h3>do-标记<a class="headerlink" href="#do" title="此标题的永久链接"></a></h3>
<p>do-标记是用于构建单子运算的快速记法，任何单子的实例都可以使用do-标记。通过使用do-标记可以使得程序模拟带有命名变量的命令式程序进行单子计算<a class="reference external" href="#ref3">[3]</a>。</p>
<p>do-标记使用<code class="docutils literal notranslate"><span class="pre">do</span></code>关键字开头，并允许在过程中使用<code class="docutils literal notranslate"><span class="pre">&lt;-</span></code>符号将monad“赋值”（或使用<code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">...</span> <span class="pre">=</span> <span class="pre">...</span></code>进行一般的赋值），最终以一个单子表达式结束。</p>
<p>回顾前面的<code class="docutils literal notranslate"><span class="pre">Maybe</span></code> monad中的示例，<code class="docutils literal notranslate"><span class="pre">maybeMonadDemo</span></code>和等效的<code class="docutils literal notranslate"><span class="pre">maybeMonadDemo'</span></code>看起来都比较抽象而难以理解，使用do-标记可以使其更简洁和方便。</p>
<div class="highlight-hs notranslate"><div class="highlight"><pre><span></span><span class="c1">-- code&#39;2.hs</span>

<span class="nf">maybeMonadDoDemo</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Maybe</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span>
<span class="nf">maybeMonadDoDemo</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span>
<span class="w">    </span><span class="kr">do</span><span class="w"> </span>
<span class="w">        </span><span class="n">x</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">string1</span>
<span class="w">        </span><span class="n">y</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">string2</span>
<span class="w">        </span><span class="n">z</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">string3</span>
<span class="w">        </span><span class="n">return</span><span class="w"> </span><span class="p">(</span><span class="n">foldr</span><span class="w"> </span><span class="p">(</span><span class="o">+</span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">(((</span><span class="nf">\</span><span class="n">x</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kr">if</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="kr">else</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">isAlpha</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;$&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">z</span><span class="p">))</span>

<span class="c1">-- 等效于</span>
<span class="nf">maybeMonadDoDemo&#39;</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Maybe</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span>
<span class="nf">maybeMonadDoDemo&#39;</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span>
<span class="w">    </span><span class="kr">do</span><span class="w"> </span><span class="p">{</span><span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">string1</span><span class="p">;</span>
<span class="w">            </span><span class="n">y</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">string2</span><span class="p">;</span>
<span class="w">            </span><span class="n">z</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">string3</span><span class="p">;</span>
<span class="w">            </span><span class="n">return</span><span class="w"> </span><span class="p">(</span><span class="n">foldr</span><span class="w"> </span><span class="p">(</span><span class="o">+</span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">(((</span><span class="nf">\</span><span class="n">x</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kr">if</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="kr">else</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">isAlpha</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;$&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">z</span><span class="p">))</span>
<span class="w">    </span><span class="p">}</span>
</pre></div>
</div>
<p>实际上，do-标记只是一种语法糖，在使用<code class="docutils literal notranslate"><span class="pre">maybeMonadDoDemo</span></code>与<code class="docutils literal notranslate"><span class="pre">maybeMonadDemo</span></code>和<code class="docutils literal notranslate"><span class="pre">maybeMonadDemo'</span></code>是完全等效的。</p>
<blockquote>
<div><p>注意：应当区分Haskell中的<code class="docutils literal notranslate"><span class="pre">return</span></code>函数与其在其他语言中的区别，在Haskell中<code class="docutils literal notranslate"><span class="pre">return</span></code>是一个函数，其本质上是将值封装为monad;而一般语言中的<code class="docutils literal notranslate"><span class="pre">return</span></code>则直接用于表示函数的返回值</p>
</div></blockquote>
<p>一般地，对于do-标记中的每一行，都有如下大致的转换过程<a class="reference external" href="#ref3">[3]</a>：</p>
<div class="highlight-hs notranslate"><div class="highlight"><pre><span></span>x &lt;- monad 表达式
...

-- 转换后
monad 表达式 &gt;&gt;= (\x -&gt; ...)
</pre></div>
</div>
<div class="highlight-hs notranslate"><div class="highlight"><pre><span></span>monad 表达式
...

-- 转换后
monad 表达式 &gt;&gt;= (\_ -&gt; ...)
</pre></div>
</div>
<div class="highlight-hs notranslate"><div class="highlight"><pre><span></span>let x = 表达式
...

-- 转换后
let x = 表达式 in ...
</pre></div>
</div>
</section>
<section id="io-monad">
<h3><code class="docutils literal notranslate"><span class="pre">IO</span></code> monad<a class="headerlink" href="#io-monad" title="此标题的永久链接"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">IO</span></code> monad 用于控制程序的输入输出，对于Haskell这种纯函数式语言来说，IO操作与其 <em><strong>引用透明(referntial transparency)</strong></em> 和 <em><strong>无副作用(side-effect free)</strong></em> 的特性相违背。通过使用<code class="docutils literal notranslate"><span class="pre">IO</span></code> monad 可以将有副作用的IO操作限制在<code class="docutils literal notranslate"><span class="pre">IO</span></code> monad中，从而保证了Haskell的纯度不会被破坏。</p>
<blockquote>
<div><p>补充：对于纯函数而言，一旦参数确定，那么结果就唯一确定，因此在任何时候对于纯函数的调用都可以被替换为计算结果，这种特性就是引用透明。</p>
</div></blockquote>
<blockquote>
<div><p>提示：本节主要对<code class="docutils literal notranslate"><span class="pre">IO</span></code> monad 作为单子的用法进行一些简要的介绍，侧重点在 monad 而非对IO操作的处理，更多内容读者可以移步 <a class="reference external" href="#">IO 专题</a></p>
</div></blockquote>
<p>在此之前，我们已经了解了<code class="docutils literal notranslate"><span class="pre">putStrLn</span></code>函数用于输出字符串，下面我们将结合<code class="docutils literal notranslate"><span class="pre">getLine</span></code>这一输入函数讲解<code class="docutils literal notranslate"><span class="pre">IO</span></code> monad的使用方法。</p>
<p><code class="docutils literal notranslate"><span class="pre">getLine</span></code>函数的类型为<code class="docutils literal notranslate"><span class="pre">IO</span> <span class="pre">String</span></code>，即进行输入IO操作后返回一个<code class="docutils literal notranslate"><span class="pre">String</span></code>类型的值；对比之下<code class="docutils literal notranslate"><span class="pre">putStrLn</span></code>函数类型为<code class="docutils literal notranslate"><span class="pre">String</span> <span class="pre">-&gt;</span> <span class="pre">IO</span> <span class="pre">()</span></code>，接受字符串后进行输出操作，但不返回任何值。</p>
<center><p><img alt="../../_images/Monad_1.png" src="../../_images/Monad_1.png" /></p>
</center><blockquote>
<div><p>注意：这里的“返回”指<code class="docutils literal notranslate"><span class="pre">IO</span></code> monad中封装的类型或者说传递给其他monad的数据的类型。因为对于<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&gt;&gt;=</span> <span class="pre">b</span></code>这种表达式，<code class="docutils literal notranslate"><span class="pre">a</span></code>计算后的值会传递给<code class="docutils literal notranslate"><span class="pre">b</span></code>，这有点类似“返回”这一行为；另外，<code class="docutils literal notranslate"><span class="pre">IO</span> <span class="pre">()</span></code>并非不传递任何值，<code class="docutils literal notranslate"><span class="pre">()</span></code>类型本身拥有唯一的值<code class="docutils literal notranslate"><span class="pre">()</span></code>，因此当我们尝试对<code class="docutils literal notranslate"><span class="pre">IO</span> <span class="pre">()</span></code>进行传值时，我们会得到一个<code class="docutils literal notranslate"><span class="pre">()</span></code>。</p>
</div></blockquote>
<p>一个最简单的应用场景就是先从键盘获取输入后，将输入值进行输出。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>Prelude&gt;<span class="w"> </span>getLine<span class="w"> </span>&gt;&gt;<span class="o">=</span><span class="w"> </span>putStrLn<span class="w"> </span>
hello
hello
Prelude&gt;<span class="w"> </span>:<span class="o">{</span>
Prelude<span class="p">|</span><span class="w"> </span><span class="k">do</span>
Prelude<span class="p">|</span><span class="w">   </span>input<span class="w"> </span>&lt;-<span class="w"> </span>getLine<span class="w"> </span>
Prelude<span class="p">|</span><span class="w">   </span>putStrLn<span class="w"> </span>input
Prelude<span class="p">|</span><span class="w"> </span>:<span class="o">}</span>
hello
hello
</pre></div>
</div>
<p>整个过程示意图如下：</p>
<center><p><img alt="../../_images/Monad_2.png" src="../../_images/Monad_2.png" /></p>
</center><p><code class="docutils literal notranslate"><span class="pre">getLine</span></code>先通过键盘读取一行字符串，并返回一个<code class="docutils literal notranslate"><span class="pre">String</span></code>类型，这个返回的数据被传入<code class="docutils literal notranslate"><span class="pre">putStrLn</span></code>函数作为参数，之后<code class="docutils literal notranslate"><span class="pre">putStrLn</span></code>将这个字符串输出<a class="reference external" href="#ref4">[4]</a>。</p>
</section>
<section id="state-monad">
<h3><code class="docutils literal notranslate"><span class="pre">State</span></code> monad<a class="headerlink" href="#state-monad" title="此标题的永久链接"></a></h3>
<p>在纯函数式语言中，我们无法进行有状态的计算，一种常见的模拟有状态计算的方法是使用<code class="docutils literal notranslate"><span class="pre">State</span></code> monad，将一个状态参数“贯穿”一系列函数<a class="reference external" href="#ref3">[3]</a>。</p>
<p><code class="docutils literal notranslate"><span class="pre">State</span></code> monad定义如下：</p>
<div class="highlight-hs notranslate"><div class="highlight"><pre><span></span><span class="c1">-- code&#39;2.hs</span>
<span class="cm">{-# LANGUAGE DeriveFunctor #-}</span>
<span class="cm">{-# LANGUAGE TupleSections #-}</span>
<span class="kr">newtype</span><span class="w"> </span><span class="kt">State</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">State</span><span class="w"> </span><span class="p">{</span><span class="n">runState</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="p">)}</span><span class="w"> </span><span class="kr">deriving</span><span class="w"> </span><span class="p">(</span><span class="kt">Functor</span><span class="p">)</span>

<span class="kr">instance</span><span class="w"> </span><span class="kt">Applicative</span><span class="w"> </span><span class="p">(</span><span class="kt">State</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span>
<span class="w">    </span><span class="n">pure</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">State</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">,)</span>
<span class="w">    </span><span class="kt">State</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">&lt;*&gt;</span><span class="w"> </span><span class="kt">State</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">State</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="nf">\</span><span class="n">s</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">fst</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">fst</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="n">s</span><span class="p">)),</span><span class="n">snd</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="n">s</span><span class="p">))</span>

<span class="kr">instance</span><span class="w"> </span><span class="kt">Monad</span><span class="w"> </span><span class="p">(</span><span class="kt">State</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span>
<span class="w">    </span><span class="kt">State</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&gt;&gt;=</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">State</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="nf">\</span><span class="n">s</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kr">let</span><span class="w"> </span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">s&#39;</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="n">runState</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="n">s&#39;</span>
</pre></div>
</div>
<blockquote>
<div><p>注意： 这里的<code class="docutils literal notranslate"><span class="pre">State</span></code> monad定义为简化版的定义，实际的<code class="docutils literal notranslate"><span class="pre">State</span></code>类型是<code class="docutils literal notranslate"><span class="pre">StateT</span></code>类型部分参数实例化的别名，类似地，也没有对于<code class="docutils literal notranslate"><span class="pre">State</span></code>的单子实例声明，而是针对<code class="docutils literal notranslate"><span class="pre">StateT</span></code>的实例声明。类型<code class="docutils literal notranslate"><span class="pre">StateT</span></code>位于<code class="docutils literal notranslate"><span class="pre">Control.Monad.State.Lazy</span></code>中<a class="reference external" href="#ref4">[3]</a>，读者可以自行参考。这里使用简化版本并不影响读者对该monad的理解和使用。</p>
</div></blockquote>
<p>我们有<code class="docutils literal notranslate"><span class="pre">evalState</span></code>和<code class="docutils literal notranslate"><span class="pre">execState</span></code>分别用于获取最终结果和最终状态（可以在库中找到，下同）,定义如下：</p>
<div class="highlight-hs notranslate"><div class="highlight"><pre><span></span><span class="c1">-- code&#39;2.hs</span>

<span class="nf">evalState</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">State</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span>
<span class="nf">evalState</span><span class="w"> </span><span class="n">act</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">fst</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">runState</span><span class="w"> </span><span class="n">act</span><span class="w"> </span>

<span class="nf">execState</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">State</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">s</span><span class="w"> </span>
<span class="nf">execState</span><span class="w"> </span><span class="n">act</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">snd</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">runState</span><span class="w"> </span><span class="n">act</span>
</pre></div>
</div>
<p>我们还可以为<code class="docutils literal notranslate"><span class="pre">State</span></code>单子提供一个标准而简单的接口–<code class="docutils literal notranslate"><span class="pre">MonadState</span></code>类型类，其定义如下：</p>
<div class="highlight-hs notranslate"><div class="highlight"><pre><span></span><span class="c1">-- code&#39;2.hs</span>
<span class="cm">{-# LANGUAGE FunctionalDependencies #-}</span>
<span class="cm">{-# LANGUAGE FlexibleInstances #-}</span>

<span class="kr">class</span><span class="w"> </span><span class="kt">MonadState</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span>
<span class="w">    </span><span class="n">get</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">s</span>
<span class="w">    </span><span class="n">get</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">state</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">s</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">s</span><span class="p">))</span><span class="w"> </span>
<span class="w">    </span><span class="n">put</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="nb">()</span>
<span class="w">    </span><span class="n">put</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">state</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="kr">_</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">()</span><span class="p">,</span><span class="n">s</span><span class="p">))</span>
<span class="w">    </span><span class="n">state</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="p">))</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">a</span>
<span class="w">    </span><span class="n">state</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span>
<span class="w">        </span><span class="n">s</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">get</span><span class="w"> </span>
<span class="w">        </span><span class="kr">let</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">s&#39;</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">s</span><span class="w"> </span>
<span class="w">        </span><span class="n">put</span><span class="w"> </span><span class="n">s&#39;</span>
<span class="w">        </span><span class="n">return</span><span class="w"> </span><span class="n">a</span>
<span class="w">    </span><span class="cm">{-# MINIMAL state | get, put #-}</span>

<span class="kr">instance</span><span class="w"> </span><span class="kt">MonadState</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="p">(</span><span class="kt">State</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span>
<span class="w">    </span><span class="n">get</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">State</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="nf">\</span><span class="n">s</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">s</span><span class="p">)</span>
<span class="w">    </span><span class="n">put</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">State</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="nf">\</span><span class="kr">_</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">()</span><span class="p">,</span><span class="n">s</span><span class="p">)</span>
</pre></div>
</div>
<p>其中<code class="docutils literal notranslate"><span class="pre">get</span></code>函数检索状态并将其作为值复制一份；<code class="docutils literal notranslate"><span class="pre">put</span></code>函数只设定状态但不生成值，<code class="docutils literal notranslate"><span class="pre">state</span></code>函数则是对原来的状态和结果进行更新。</p>
<p>下面我们尝试应用<code class="docutils literal notranslate"><span class="pre">State</span></code> monad实现一个栈结构，一个栈结构需要压入栈(push)、弹出栈(pop)以及查看栈顶(peek)三种操作。</p>
<p>首先实现栈数据结构，我们使用列表进行存储。</p>
<div class="highlight-hs notranslate"><div class="highlight"><pre><span></span><span class="c1">-- code&#39;2.hs</span>

<span class="kr">type</span><span class="w"> </span><span class="kt">Stack</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="kt">Int</span><span class="p">]</span>
</pre></div>
</div>
<p>对于入栈，应当接受一个<code class="docutils literal notranslate"><span class="pre">Int</span></code>参数，并改变栈的状态，如下：</p>
<div class="highlight-hs notranslate"><div class="highlight"><pre><span></span><span class="c1">-- code&#39;2.hs</span>

<span class="nf">push</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">State</span><span class="w"> </span><span class="kt">Stack</span><span class="w"> </span><span class="nb">()</span>
<span class="nf">push</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">state</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="nf">\</span><span class="n">xs</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">()</span><span class="p">,</span><span class="n">x</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="n">xs</span><span class="p">)</span>
</pre></div>
</div>
<p>对于出栈，应当改变栈的状态，将栈顶元素弹出并作为最终结果，如下：</p>
<div class="highlight-hs notranslate"><div class="highlight"><pre><span></span><span class="c1">-- code&#39;2.hs</span>

<span class="nf">pop</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">State</span><span class="w"> </span><span class="kt">Stack</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span>
<span class="nf">pop</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">state</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="nf">\</span><span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">xs</span><span class="p">)</span>
</pre></div>
</div>
<p>最后，观察函数不改变状态，但将栈顶元素作为最终结果，如下：</p>
<div class="highlight-hs notranslate"><div class="highlight"><pre><span></span><span class="c1">-- code&#39;2.hs</span>

<span class="nf">peek</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">State</span><span class="w"> </span><span class="kt">Stack</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span>
<span class="nf">peek</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">state</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="nf">\</span><span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span>
</pre></div>
</div>
<p>下面尝试测试这些栈活动，例如可以使用栈进行加法运算<code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">+</span> <span class="pre">2</span></code>:</p>
<div class="highlight-hs notranslate"><div class="highlight"><pre><span></span><span class="c1">-- code&#39;2.hs</span>
<span class="nf">makestack</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">State</span><span class="w"> </span><span class="kt">Stack</span><span class="w"> </span><span class="nb">()</span>
<span class="nf">makestack</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span>
<span class="w">    </span><span class="n">push</span><span class="w"> </span><span class="mi">1</span>
<span class="w">    </span><span class="n">push</span><span class="w"> </span><span class="mi">2</span>

<span class="nf">add</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">State</span><span class="w"> </span><span class="kt">Stack</span><span class="w"> </span><span class="nb">()</span>
<span class="nf">add</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"> </span>
<span class="w">    </span><span class="n">a</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">pop</span>
<span class="w">    </span><span class="n">b</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">pop</span>
<span class="w">    </span><span class="kr">let</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span>
<span class="w">    </span><span class="n">push</span><span class="w"> </span><span class="n">c</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">makestack</span></code>将两个数字压入栈中，<code class="docutils literal notranslate"><span class="pre">add</span></code>将两个数字弹出栈，并将计算结果重新压入栈中。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>Prelude&gt;<span class="w"> </span>evalState<span class="w"> </span><span class="o">(</span>makestack<span class="w"> </span>&gt;&gt;<span class="w"> </span>add<span class="w"> </span>&gt;&gt;<span class="w"> </span>peek<span class="o">)</span><span class="w"> </span><span class="o">[]</span>
<span class="m">3</span>
</pre></div>
</div>
</section>
<section id="reader-monad">
<h3><code class="docutils literal notranslate"><span class="pre">Reader</span></code> monad<a class="headerlink" href="#reader-monad" title="此标题的永久链接"></a></h3>
<p>当我们需要从一个共享环境中读取信息并进行计算时，但不需要改变环境的状态时，就可以使用<code class="docutils literal notranslate"><span class="pre">Reader</span></code> monad。<code class="docutils literal notranslate"><span class="pre">Reader</span></code> monad可以在这种特定的场景下替代<code class="docutils literal notranslate"><span class="pre">State</span></code> monad，以便表达更清晰容易<a class="reference external" href="#ref3">[3]</a>。</p>
<p><code class="docutils literal notranslate"><span class="pre">Reader</span></code> monad 定义如下（同样，这也是简化后的版本）：</p>
<div class="highlight-hs notranslate"><div class="highlight"><pre><span></span><span class="c1">-- code&#39;2.hs</span>

<span class="kr">newtype</span><span class="w"> </span><span class="kt">Reader</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Reader</span><span class="w"> </span><span class="p">{</span><span class="n">runReader</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="p">}</span><span class="w"> </span><span class="kr">deriving</span><span class="w"> </span><span class="p">(</span><span class="kt">Functor</span><span class="p">)</span>

<span class="kr">instance</span><span class="w"> </span><span class="kt">Applicative</span><span class="w"> </span><span class="p">(</span><span class="kt">Reader</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span>
<span class="w">    </span><span class="n">pure</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Reader</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="nf">\</span><span class="n">e</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span>
<span class="w">    </span><span class="kt">Reader</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">&lt;*&gt;</span><span class="w"> </span><span class="kt">Reader</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Reader</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="nf">\</span><span class="n">e</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="n">e</span><span class="p">)</span>

<span class="kr">instance</span><span class="w"> </span><span class="kt">Monad</span><span class="w"> </span><span class="p">(</span><span class="kt">Reader</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span>
<span class="w">    </span><span class="p">(</span><span class="kt">Reader</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;=</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Reader</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="nf">\</span><span class="n">e</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">runReader</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="n">r</span><span class="w"> </span><span class="n">e</span><span class="p">))</span><span class="w"> </span><span class="n">e</span>
</pre></div>
</div>
<p>类似<code class="docutils literal notranslate"><span class="pre">MonadState</span></code>，我们也可以写一个<code class="docutils literal notranslate"><span class="pre">MonadReader</span></code>提供一些基础的函数。</p>
<div class="highlight-hs notranslate"><div class="highlight"><pre><span></span><span class="c1">-- code&#39;2.hs</span>

<span class="kr">class</span><span class="w"> </span><span class="kt">Monad</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">MonadReader</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span>
<span class="w">    </span><span class="n">ask</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">e</span><span class="w"> </span>
<span class="w">    </span><span class="n">ask</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">reader</span><span class="w"> </span><span class="n">id</span><span class="w"> </span>
<span class="w">    </span><span class="n">local</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="n">e</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">a</span><span class="w"> </span>
<span class="w">    </span><span class="n">reader</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="n">e</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">a</span><span class="w"> </span>
<span class="w">    </span><span class="n">reader</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"> </span>
<span class="w">        </span><span class="n">r</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">ask</span><span class="w"> </span>
<span class="w">        </span><span class="n">return</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">r</span><span class="p">)</span>

<span class="kr">instance</span><span class="w"> </span><span class="kt">MonadReader</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="p">(</span><span class="kt">Reader</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span>
<span class="w">    </span><span class="n">local</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Reader</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="nf">\</span><span class="n">e</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">runReader</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">e</span><span class="p">)</span>
</pre></div>
</div>
<p>其中<code class="docutils literal notranslate"><span class="pre">ask</span></code>函数用于读取当前环境，<code class="docutils literal notranslate"><span class="pre">local</span></code>函数进行环境的局部修改（即不会影响到全局环境）。</p>
<p>由于<code class="docutils literal notranslate"><span class="pre">Reader</span></code>中并没有保存有关环境的信息（相比之下<code class="docutils literal notranslate"><span class="pre">State</span></code>中将<code class="docutils literal notranslate"><span class="pre">s</span></code>存储在元组中），因此<code class="docutils literal notranslate"><span class="pre">local</span></code>只是局部有效。</p>
</section>
<section id="writer-monad">
<h3><code class="docutils literal notranslate"><span class="pre">Writer</span></code> monad<a class="headerlink" href="#writer-monad" title="此标题的永久链接"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">Writer</span></code> monad 在计算的同时还生成输出，例如日志记录和跟踪。这些输出不是计算的主要结果，但是必要保留的信息，通过使用<code class="docutils literal notranslate"><span class="pre">Writer</span></code> monad可以更简洁地管理输出，不会使主要地计算变得混乱<a class="reference external" href="#ref3">[3]</a>。</p>
<p><code class="docutils literal notranslate"><span class="pre">Writer</span></code> monad 的（简化后的）定义如下:</p>
<div class="highlight-hs notranslate"><div class="highlight"><pre><span></span><span class="c1">-- code&#39;2.hs</span>

<span class="kr">newtype</span><span class="w"> </span><span class="kt">Writer</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Writer</span><span class="w"> </span><span class="p">{</span><span class="n">runWriter</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">w</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">deriving</span><span class="w"> </span><span class="p">(</span><span class="kt">Functor</span><span class="p">)</span>

<span class="kr">instance</span><span class="w"> </span><span class="kt">Monoid</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Applicative</span><span class="w"> </span><span class="p">(</span><span class="kt">Writer</span><span class="w"> </span><span class="n">w</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span>
<span class="w">    </span><span class="n">pure</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Writer</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">mempty</span><span class="p">)</span>
<span class="w">    </span><span class="kt">Writer</span><span class="w"> </span><span class="p">(</span><span class="n">fa</span><span class="p">,</span><span class="n">w&#39;</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;*&gt;</span><span class="w"> </span><span class="kt">Writer</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">w</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Writer</span><span class="w"> </span><span class="p">(</span><span class="n">fa</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="n">w&#39;</span><span class="w"> </span><span class="p">`</span><span class="n">mappend</span><span class="p">`</span><span class="w"> </span><span class="n">w</span><span class="p">)</span><span class="w"> </span>

<span class="kr">instance</span><span class="w"> </span><span class="kt">Monoid</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Monad</span><span class="w"> </span><span class="p">(</span><span class="kt">Writer</span><span class="w"> </span><span class="n">w</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span>
<span class="w">    </span><span class="kt">Writer</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">w</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;=</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">let</span><span class="w"> </span><span class="p">(</span><span class="n">a&#39;</span><span class="p">,</span><span class="n">w&#39;</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">runWriter</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span>
<span class="w">        </span><span class="kt">Writer</span><span class="w"> </span><span class="p">(</span><span class="n">a&#39;</span><span class="p">,</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="p">`</span><span class="n">mappend</span><span class="p">`</span><span class="w"> </span><span class="n">w&#39;</span><span class="p">)</span><span class="w">     </span>
</pre></div>
</div>
<p>类似地，我们可以写一个<code class="docutils literal notranslate"><span class="pre">MonadWriter</span></code>类型类，提供一些基础函数。</p>
<div class="highlight-hs notranslate"><div class="highlight"><pre><span></span><span class="c1">-- code&#39;2.hs</span>

<span class="kr">class</span><span class="w"> </span><span class="p">(</span><span class="kt">Monoid</span><span class="w"> </span><span class="n">w</span><span class="p">,</span><span class="w"> </span><span class="kt">Monad</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">MonadWriter</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span>
<span class="w">    </span><span class="n">pass</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">w</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">a</span><span class="w"> </span>
<span class="w">    </span><span class="n">listen</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">w</span><span class="p">)</span>
<span class="w">    </span><span class="n">tell</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="nb">()</span><span class="w"> </span>
<span class="w">    </span><span class="n">tell</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">writer</span><span class="w"> </span><span class="p">(</span><span class="nb">()</span><span class="p">,</span><span class="n">w</span><span class="p">)</span>
<span class="w">    </span><span class="n">writer</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">w</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">a</span>
<span class="w">    </span><span class="n">writer</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">w</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"> </span>
<span class="w">            </span><span class="n">tell</span><span class="w"> </span><span class="n">w</span><span class="w"> </span>
<span class="w">            </span><span class="n">return</span><span class="w"> </span><span class="n">a</span><span class="w">  </span>
<span class="w">    </span><span class="cm">{-# MINIMAL (writer | tell), listen, pass #-}</span>

<span class="kr">instance</span><span class="w"> </span><span class="kt">Monoid</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">MonadWriter</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="p">(</span><span class="kt">Writer</span><span class="w"> </span><span class="n">w</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span>
<span class="w">  </span><span class="n">pass</span><span class="w"> </span><span class="p">(</span><span class="kt">Writer</span><span class="w"> </span><span class="p">((</span><span class="n">a</span><span class="p">,</span><span class="n">f</span><span class="p">),</span><span class="n">w</span><span class="p">))</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Writer</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">f</span><span class="w"> </span><span class="n">w</span><span class="p">)</span>
<span class="w">  </span><span class="n">listen</span><span class="w"> </span><span class="p">(</span><span class="kt">Writer</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">w</span><span class="p">))</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Writer</span><span class="w"> </span><span class="p">((</span><span class="n">a</span><span class="p">,</span><span class="n">w</span><span class="p">),</span><span class="n">w</span><span class="p">)</span>
<span class="w">  </span><span class="n">tell</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Writer</span><span class="w"> </span><span class="p">(</span><span class="nb">()</span><span class="p">,</span><span class="n">s</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">tell</span></code>函数单纯产生一个输出；<code class="docutils literal notranslate"><span class="pre">listen</span></code>函数将<code class="docutils literal notranslate"><span class="pre">Writer</span></code>中的输出<code class="docutils literal notranslate"><span class="pre">w</span></code>作为值的一部分，连同原来的值一起形成新的值（元组）<code class="docutils literal notranslate"><span class="pre">(a,w)</span></code>，这允许计算能够“听到”输出的内容；<code class="docutils literal notranslate"><span class="pre">pass</span></code>函数将值中函数<code class="docutils literal notranslate"><span class="pre">f</span></code>移除，并作用在输出中。</p>
<p>一般情况下，<code class="docutils literal notranslate"><span class="pre">pass</span></code>会有些麻烦，因为<code class="docutils literal notranslate"><span class="pre">f</span></code>位于值中，通常我们使用一个类似的函数<code class="docutils literal notranslate"><span class="pre">censor</span></code>，该函数将<code class="docutils literal notranslate"><span class="pre">f</span></code>作为一个参数吸收进来，并生成为<code class="docutils literal notranslate"><span class="pre">pass</span></code>函数可以处理的结构。</p>
<div class="highlight-hs notranslate"><div class="highlight"><pre><span></span><span class="c1">-- code&#39;2.hs</span>

<span class="nf">censor</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="kt">MonadWriter</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">w</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">w</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">a</span>
<span class="nf">censor</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">pass</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="kr">do</span><span class="w"> </span>
<span class="w">            </span><span class="n">a</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">m</span>
<span class="w">            </span><span class="n">return</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
<p>另一个常用的函数是<code class="docutils literal notranslate"><span class="pre">listens</span></code>,它可以看作<code class="docutils literal notranslate"><span class="pre">listen</span></code>函数的升级版, 提供对输出进行处理的功能。</p>
<div class="highlight-hs notranslate"><div class="highlight"><pre><span></span><span class="c1">-- code&#39;2.hs</span>

<span class="nf">listens</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="kt">MonadWriter</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">w</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
<span class="nf">listens</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"> </span>
<span class="w">        </span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">w</span><span class="p">)</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">listen</span><span class="w"> </span><span class="n">m</span><span class="w"> </span>
<span class="w">        </span><span class="n">return</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">f</span><span class="w"> </span><span class="n">w</span><span class="p">)</span>
</pre></div>
</div>
</section>
</section>
<section id="monad-monadplus">
<h2>增强Monad <code class="docutils literal notranslate"><span class="pre">MonadPlus</span></code><a class="headerlink" href="#monad-monadplus" title="此标题的永久链接"></a></h2>
<p><code class="docutils literal notranslate"><span class="pre">MonadPlus</span></code>可以认为是<code class="docutils literal notranslate"><span class="pre">Monad</span></code>的增强版，其定义的是满足幺半群的单子类型类，定义如下：</p>
<div class="highlight-hs notranslate"><div class="highlight"><pre><span></span><span class="kr">class</span><span class="w"> </span><span class="p">(</span><span class="kt">Monad</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="kt">Alternative</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">MonadPlus</span><span class="w"> </span><span class="p">(</span><span class="n">m</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span>
<span class="w">    </span><span class="n">mzero</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">a</span><span class="w"> </span>
<span class="w">    </span><span class="n">mplus</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">a</span>
</pre></div>
</div>
<p>例如前面的<code class="docutils literal notranslate"><span class="pre">MonadWriter</span></code> 实例就可以使用<code class="docutils literal notranslate"><span class="pre">MonadPlus</span></code>约束替换。</p>
</section>
<section id="id4">
<h2>monad 转换器<a class="headerlink" href="#id4" title="此标题的永久链接"></a></h2>
<p><em><strong>monad 转换器(Monad Transformer)</strong></em> 将不同的monad组合起来，使其同时具备多种monad的行为。monad 转换器通过将原始monad构造函数中添加monad参数，以生成新的构造函数，从而得到组合的单子类型<a class="reference external" href="#ref3">[3]</a>。</p>
<section id="identityt-monad">
<h3>IdentityT monad 转换器<a class="headerlink" href="#identityt-monad" title="此标题的永久链接"></a></h3>
<p>我们首先介绍最简单的转换器以便读者能够有一个简单的认识，<code class="docutils literal notranslate"><span class="pre">IdentityT</span></code> 是 <code class="docutils literal notranslate"><span class="pre">Identity</span></code> 的转换器，其原理为添加了容纳单子参数的<code class="docutils literal notranslate"><span class="pre">m</span></code>，如下：</p>
<div class="highlight-hs notranslate"><div class="highlight"><pre><span></span><span class="c1">-- code&#39;2.hs</span>

<span class="kr">newtype</span><span class="w"> </span><span class="kt">IdentityT</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">IdentityT</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">runIdentityT</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">deriving</span><span class="w"> </span><span class="p">(</span><span class="kt">Functor</span><span class="p">)</span>
</pre></div>
</div>
<p>我们为其声明单子实例：</p>
<div class="highlight-hs notranslate"><div class="highlight"><pre><span></span><span class="c1">-- code&#39;2.hs</span>

<span class="kr">instance</span><span class="w"> </span><span class="kt">Applicative</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Applicative</span><span class="w"> </span><span class="p">(</span><span class="kt">IdentityT</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span>
<span class="w">  </span><span class="n">pure</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">IdentityT</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">pure</span><span class="w"> </span><span class="n">a</span>
<span class="w">  </span><span class="kt">IdentityT</span><span class="w"> </span><span class="n">mf</span><span class="w"> </span><span class="o">&lt;*&gt;</span><span class="w"> </span><span class="kt">IdentityT</span><span class="w"> </span><span class="n">ma</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">IdentityT</span><span class="w"> </span><span class="p">(</span><span class="n">mf</span><span class="w"> </span><span class="o">&lt;*&gt;</span><span class="w"> </span><span class="n">ma</span><span class="p">)</span>

<span class="kr">instance</span><span class="w"> </span><span class="kt">Monad</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Monad</span><span class="w"> </span><span class="p">(</span><span class="kt">IdentityT</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span>
<span class="w">  </span><span class="n">m</span><span class="w"> </span><span class="o">&gt;&gt;=</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">IdentityT</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="kr">do</span><span class="w"> </span>
<span class="w">            </span><span class="n">a</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">runIdentityT</span><span class="w"> </span><span class="n">m</span><span class="w"> </span>
<span class="w">            </span><span class="n">runIdentityT</span><span class="w"> </span><span class="p">(</span><span class="n">k</span><span class="w"> </span><span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
<p>至此我们可以将<code class="docutils literal notranslate"><span class="pre">IdnetityT</span></code>与其他monad组合，例如<code class="docutils literal notranslate"><span class="pre">Maybe</span></code> monad。</p>
<div class="highlight-hs notranslate"><div class="highlight"><pre><span></span><span class="c1">-- code&#39;2.hs</span>

<span class="kr">type</span><span class="w"> </span><span class="kt">IdentityMaybe</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">IdentityT</span><span class="w"> </span><span class="kt">Maybe</span><span class="w"> </span><span class="n">a</span>
</pre></div>
</div>
<p>我们沿用<code class="docutils literal notranslate"><span class="pre">Maybe</span></code> monad中的示例，演示如何使用<code class="docutils literal notranslate"><span class="pre">IdentityT</span></code> monad转换器。</p>
<div class="highlight-hs notranslate"><div class="highlight"><pre><span></span><span class="c1">-- code&#39;2.hs</span>

<span class="nf">string1&#39;</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">IdentityT</span><span class="w"> </span><span class="n">string1</span>

<span class="nf">string2&#39;</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">IdentityT</span><span class="w"> </span><span class="n">string2</span>

<span class="nf">string3&#39;</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">IdentityT</span><span class="w"> </span><span class="n">string3</span>

<span class="nf">identityMaybeMonadTDemo</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">IdentityMaybe</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span>
<span class="nf">identityMaybeMonadTDemo</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span>
<span class="w">    </span><span class="kr">do</span><span class="w"> </span>
<span class="w">        </span><span class="n">x</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">string1&#39;</span>
<span class="w">        </span><span class="n">y</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">string2&#39;</span>
<span class="w">        </span><span class="n">z</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">string3&#39;</span>
<span class="w">        </span><span class="n">return</span><span class="w"> </span><span class="p">(</span><span class="n">foldr</span><span class="w"> </span><span class="p">(</span><span class="o">+</span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">(((</span><span class="nf">\</span><span class="n">x</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kr">if</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="kr">else</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">isAlpha</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;$&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">z</span><span class="p">))</span>
</pre></div>
</div>
</section>
<section id="monad-monadtrans">
<h3>monad 提升 <code class="docutils literal notranslate"><span class="pre">MonadTrans</span></code><a class="headerlink" href="#monad-monadtrans" title="此标题的永久链接"></a></h3>
<p>Haskell中有很多monad 转换器，它们可以归纳出共同的性质，这些性质被封装到了<code class="docutils literal notranslate"><span class="pre">MonadTrans</span></code>类型类中，该类型类位于<code class="docutils literal notranslate"><span class="pre">Control.Monad.Trans</span></code>。</p>
<p><code class="docutils literal notranslate"><span class="pre">MonadTrans</span></code>定义如下：</p>
<div class="highlight-hs notranslate"><div class="highlight"><pre><span></span><span class="c1">-- code&#39;2.hs</span>

<span class="kr">class</span><span class="w"> </span><span class="kt">MonadTrans</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span>
<span class="w">    </span><span class="n">lift</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Monad</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">a</span>
</pre></div>
</div>
<p>其中<code class="docutils literal notranslate"><span class="pre">lift</span></code>意为“提升函数”，它可以将某个monad提升为与某个转换器的组合。</p>
<p>例如前面的<code class="docutils literal notranslate"><span class="pre">IdentityT</span></code>转换器：</p>
<div class="highlight-hs notranslate"><div class="highlight"><pre><span></span><span class="c1">-- code&#39;2.hs</span>

<span class="kr">instance</span><span class="w"> </span><span class="kt">MonadTrans</span><span class="w"> </span><span class="kt">IdentityT</span><span class="w">  </span><span class="kr">where</span><span class="w"> </span>
<span class="w">  </span><span class="n">lift</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="ow">=</span><span class="w">  </span><span class="kt">IdentityT</span><span class="w"> </span><span class="n">m</span>
</pre></div>
</div>
<p>因此，前面的示例可以写成：</p>
<div class="highlight-hs notranslate"><div class="highlight"><pre><span></span><span class="c1">-- code&#39;2.hs</span>

<span class="nf">identityMaybeMoandTDemo&#39;</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">IdentityMaybe</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span>
<span class="nf">identityMaybeMoandTDemo&#39;</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span>
<span class="w">    </span><span class="kr">do</span><span class="w"> </span>
<span class="w">        </span><span class="n">x</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">lift</span><span class="w"> </span><span class="n">string1</span><span class="w"> </span>
<span class="w">        </span><span class="n">y</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">lift</span><span class="w"> </span><span class="n">string2</span><span class="w"> </span>
<span class="w">        </span><span class="n">z</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">lift</span><span class="w"> </span><span class="n">string3</span><span class="w"> </span>
<span class="w">        </span><span class="n">return</span><span class="w"> </span><span class="p">(</span><span class="n">foldr</span><span class="w"> </span><span class="p">(</span><span class="o">+</span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">(((</span><span class="nf">\</span><span class="n">x</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kr">if</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="kr">else</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">isAlpha</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;$&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">z</span><span class="p">))</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">lift</span></code>函数允许我们仅仅定义原始monad值，并自动转换为带有转换器的组合monad类型。</p>
<section id="lift">
<h4><code class="docutils literal notranslate"><span class="pre">lift</span></code> 定律<a class="headerlink" href="#lift" title="此标题的永久链接"></a></h4>
<p><code class="docutils literal notranslate"><span class="pre">lift</span></code>函数应当人为保证满足以下定律：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">lift</span> <span class="pre">.</span> <span class="pre">return</span> <span class="pre">=</span> <span class="pre">return</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">lift</span> <span class="pre">(m</span> <span class="pre">&gt;&gt;=</span> <span class="pre">f)</span> <span class="pre">=</span> <span class="pre">lift</span> <span class="pre">m</span> <span class="pre">&gt;&gt;=</span> <span class="pre">(lift</span> <span class="pre">.</span> <span class="pre">f)</span></code></p></li>
</ul>
</section>
</section>
<section id="io-monad-monadio">
<h3>IO monad 提升 <code class="docutils literal notranslate"><span class="pre">MonadIO</span></code><a class="headerlink" href="#io-monad-monadio" title="此标题的永久链接"></a></h3>
<p>由于我们并没有IO monad的转换器，因此当组合的monad行为中需要IO操作时，IO monad往往作为其他转换器的参数，当然也就无法使用<code class="docutils literal notranslate"><span class="pre">MonadTrans</span></code>类型类。</p>
<p>Haskell中提供了一个<code class="docutils literal notranslate"><span class="pre">MonadIO</span></code>用于将IO操作提升的函数<code class="docutils literal notranslate"><span class="pre">liftIO</span></code>，具体定义如下：</p>
<div class="highlight-hs notranslate"><div class="highlight"><pre><span></span><span class="kr">class</span><span class="w"> </span><span class="kt">Monad</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">MonadIO</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span>
<span class="w">    </span><span class="n">liftIO</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">IO</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">a</span><span class="w"> </span>
<span class="w">    </span><span class="cm">{-# MINIMAL liftIO #-}</span>
</pre></div>
</div>
<p>该定义位于<code class="docutils literal notranslate"><span class="pre">Control.Monad.IO.Class</span></code>，一旦我们拥有<code class="docutils literal notranslate"><span class="pre">MonadIO</span></code>实现的转换器（或者说组合monad），就可以将其IO操作提升至该monad。</p>
<p>例如最简单的转换器<code class="docutils literal notranslate"><span class="pre">IdentityT</span></code>。</p>
<div class="highlight-hs notranslate"><div class="highlight"><pre><span></span><span class="c1">-- code&#39;2.hs</span>

<span class="kr">import</span><span class="w"> </span><span class="nn">Control.Monad.IO.Class</span>

<span class="kr">instance</span><span class="w"> </span><span class="kt">MonadIO</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">MonadIO</span><span class="w"> </span><span class="p">(</span><span class="kt">IdentityT</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span>
<span class="w">    </span><span class="n">liftIO</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">IdentityT</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">liftIO</span><span class="w">  </span>
</pre></div>
</div>
<blockquote>
<div><p>提示：实际上，该实例已经在<code class="docutils literal notranslate"><span class="pre">Control.Monad.Trans.Identity</span></code>中定义</p>
</div></blockquote>
<p>模仿前面的示例，但改为读取三行字符串，并计算其中非字母的字符数。</p>
<div class="highlight-hs notranslate"><div class="highlight"><pre><span></span><span class="c1">-- code&#39;2.hs</span>

<span class="nf">identityIOMonadTDemo</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">IdentityT</span><span class="w"> </span><span class="kt">IO</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span>
<span class="nf">identityIOMonadTDemo</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span>
<span class="w">    </span><span class="kr">do</span><span class="w"> </span>
<span class="w">        </span><span class="n">x</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">liftIO</span><span class="w"> </span><span class="n">getLine</span>
<span class="w">        </span><span class="n">y</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">liftIO</span><span class="w"> </span><span class="n">getLine</span><span class="w"> </span>
<span class="w">        </span><span class="n">z</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">liftIO</span><span class="w"> </span><span class="n">getLine</span><span class="w"> </span>
<span class="w">        </span><span class="n">return</span><span class="w"> </span><span class="p">(</span><span class="n">foldr</span><span class="w"> </span><span class="p">(</span><span class="o">+</span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">(((</span><span class="nf">\</span><span class="n">x</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kr">if</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="kr">else</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">isAlpha</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;$&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">z</span><span class="p">))</span>
</pre></div>
</div>
</section>
<section id="id5">
<h3>多次 monad 提升<a class="headerlink" href="#id5" title="此标题的永久链接"></a></h3>
<p>类似<code class="docutils literal notranslate"><span class="pre">IO</span></code>这类无法实现转换器的monad有很多，因此一种比较好的方法是将这类monad的性质抽象出来。<code class="docutils literal notranslate"><span class="pre">MonadBase</span></code>位于<code class="docutils literal notranslate"><span class="pre">transformers-base</span></code>库的<code class="docutils literal notranslate"><span class="pre">Control.Monad.Base</span></code>，其内含有函数<code class="docutils literal notranslate"><span class="pre">liftBase</span></code>，能够一次性将monad提升到顶层，而无需多次使用lift函数<a class="reference external" href="#ref5">[5]</a>。</p>
<div class="highlight-hs notranslate"><div class="highlight"><pre><span></span><span class="kr">class</span><span class="w"> </span><span class="p">(</span><span class="kt">Applicative</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="kt">Applicative</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="kt">Monad</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="kt">Monad</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">MonadBase</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span>
<span class="w">    </span><span class="n">liftBase</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">α</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">α</span>
<span class="w">    </span><span class="cm">{-# MINIMAL liftBase #-}</span>
</pre></div>
</div>
<p>Haskell提供了提升的默认递归实现<code class="docutils literal notranslate"><span class="pre">liftBaseDefault</span></code>，即</p>
<div class="highlight-hs notranslate"><div class="highlight"><pre><span></span><span class="c1">-- code&#39;2.hs</span>

<span class="kr">import</span><span class="w"> </span><span class="nn">Control.Monad.Base</span><span class="p">(</span><span class="kt">MonadBase</span><span class="p">,</span><span class="n">liftBase</span><span class="p">)</span>

<span class="nf">liftBaseDefault</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="kt">MonadTrans</span><span class="w"> </span><span class="n">t</span><span class="p">,</span><span class="w"> </span><span class="kt">MonadBase</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">α</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">α</span>
<span class="nf">liftBaseDefault</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">lift</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">liftBase</span><span class="w"> </span>

<span class="kr">instance</span><span class="w"> </span><span class="p">(</span><span class="kt">MonadTrans</span><span class="w"> </span><span class="n">t</span><span class="p">,</span><span class="kt">MonadBase</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="kt">Monad</span><span class="w"> </span><span class="p">(</span><span class="n">t</span><span class="w"> </span><span class="n">m</span><span class="p">))</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">MonadBase</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="p">(</span><span class="n">t</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span>
<span class="w">  </span><span class="n">liftBase</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">liftBaseDefault</span><span class="w"> </span>
</pre></div>
</div>
<blockquote>
<div><p>注意：使用这种递归必须保证递归的基本情况的实例已经被声明，Haskell已经内置了一些实例，如<code class="docutils literal notranslate"><span class="pre">MonadBase</span> <span class="pre">IO</span> <span class="pre">IO</span></code>等，读者可以自行查阅</p>
</div></blockquote>
<p>使用<code class="docutils literal notranslate"><span class="pre">IdentityT</span></code>嵌套转换器，并使用<code class="docutils literal notranslate"><span class="pre">liftBase</span></code>提升至顶层：</p>
<div class="highlight-hs notranslate"><div class="highlight"><pre><span></span><span class="c1">-- code&#39;2.hs</span>

<span class="nf">liftBaseDemo</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">IdentityT</span><span class="w"> </span><span class="p">(</span><span class="kt">IdentityT</span><span class="w"> </span><span class="kt">IO</span><span class="p">)</span><span class="w"> </span><span class="kt">Int</span>
<span class="nf">liftBaseDemo</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span>
<span class="w">    </span><span class="kr">do</span><span class="w"> </span>
<span class="w">        </span><span class="n">x</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">liftBase</span><span class="w"> </span><span class="n">getLine</span><span class="w"> </span>
<span class="w">        </span><span class="n">y</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">liftBase</span><span class="w"> </span><span class="n">getLine</span><span class="w"> </span>
<span class="w">        </span><span class="n">z</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">liftBase</span><span class="w"> </span><span class="n">getLine</span><span class="w"> </span>
<span class="w">        </span><span class="n">return</span><span class="w"> </span><span class="p">(</span><span class="n">foldr</span><span class="w"> </span><span class="p">(</span><span class="o">+</span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">(((</span><span class="nf">\</span><span class="n">x</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kr">if</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="kr">else</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">isAlpha</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;$&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">z</span><span class="p">))</span><span class="w"> </span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">getLine</span></code>类型为<code class="docutils literal notranslate"><span class="pre">IO</span> <span class="pre">String</span></code>，根据前面声明的实例，<code class="docutils literal notranslate"><span class="pre">liftBase</span></code>函数将<code class="docutils literal notranslate"><span class="pre">IO</span> <span class="pre">String</span></code>先提升为<code class="docutils literal notranslate"><span class="pre">IdentityT</span> <span class="pre">IO</span> <span class="pre">String</span></code>，然后又提升为 <code class="docutils literal notranslate"><span class="pre">IdentityT</span> <span class="pre">(IdentityT</span> <span class="pre">IO)</span> <span class="pre">String</span></code>，使其能够在<code class="docutils literal notranslate"><span class="pre">do</span></code>标记的语法块中进行运算。</p>
</section>
<section id="id6">
<h3>更多 monad 转换器<a class="headerlink" href="#id6" title="此标题的永久链接"></a></h3>
<p>下面列出一些内置的标准monad转换器版本：</p>
<table border="1" class="docutils">
<thead>
<tr>
<th>原始单子</th>
<th>原始类型</th>
<th>转换器版本</th>
<th>组合类型</th>
<th>位置</th>
</tr>
</thead>
<tbody>
<tr>
<td>Maybe</td>
<td>Maybe a</td>
<td>MaybeT</td>
<td>MaybeT (m (Maybe a))</td>
<td>transformers <code>Control.Monad.Trans.Maybe</code></td>
</tr>
<tr>
<td>Either</td>
<td>Either e a</td>
<td>EitherT</td>
<td>m (Either e a)</td>
<td>transformers-either <code>Control.Monad.Trans.Either</code></td>
</tr>
<tr>
<td>State</td>
<td>State (s -&gt; (a,s))</td>
<td>StateT</td>
<td>StateT (s -&gt; m (a, s))</td>
<td>transformers <code>Control.Monad.Trans.State.Lazy</code></td>
</tr>
<tr>
<td>Reader</td>
<td>Reader (e -&gt; a)</td>
<td>ReaderT</td>
<td>ReaderT (r -&gt; m a)</td>
<td>transformers <code>Control.Monad.Trans.State.Lazy</code></td>
</tr>
<tr>
<td>Writer</td>
<td>Writer (a, w)</td>
<td>WriterT</td>
<td>WriterT (m (a, w))</td>
<td>transformers <code>Control.Monad.Trans.Writer.Lazy</code></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table><hr class="docutils" />
<p id="ref1">[1] Merely monadic. (2021, March 16). HaskellWiki, . Retrieved 02:27, April 20, 2024 from https://wiki.haskell.org/index.php?title=Merely_monadic&oldid=64044.</p>
<p id="ref2">[2] Monad. (2022, October 22). HaskellWiki, . Retrieved 02:46, April 20, 2024 from https://wiki.haskell.org/index.php?title=Monad&oldid=65405.</p>
<p id="ref3">[3] All About Monads. (2021, September 19). HaskellWiki, . Retrieved 03:13, April 22, 2024 from https://wiki.haskell.org/index.php?title=All_About_Monads&oldid=64741.</p>
<p id="ref4">[4] State Monad. (2018, December 21). HaskellWiki, . Retrieved 06:21, April 22, 2024 from https://wiki.haskell.org/index.php?title=State_Monad&oldid=62675.</p>
<p id="ref5">[5] New monads/MonadBase. (2006, October 26). HaskellWiki, . Retrieved 06:36, May 2, 2024 from https://wiki.haskell.org/index.php?title=New_monads/MonadBase&oldid=7351.</p></section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="页脚">
        <a href="%E5%87%BD%E5%AD%90%E4%B8%93%E9%A2%98.html" class="btn btn-neutral float-left" title="函子专题" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> 上一页</a>
        <a href="../%E8%B5%84%E6%BA%90.html" class="btn btn-neutral float-right" title="资源" accesskey="n" rel="next">下一页 <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; 版权所有 2024, Alfred Xiang.</p>
  </div>

  利用 <a href="https://www.sphinx-doc.org/">Sphinx</a> 构建，使用的 
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">主题</a>
    由 <a href="https://readthedocs.org">Read the Docs</a> 开发.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>