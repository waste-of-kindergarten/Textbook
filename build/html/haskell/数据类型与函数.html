<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN">
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>数据类型与函数 &mdash; TextBook v0.1 文档</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css" />
      <link rel="stylesheet" type="text/css" href="../_static/dark_mode_css/general.css" />
      <link rel="stylesheet" type="text/css" href="../_static/dark_mode_css/dark.css" />

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/sphinx_highlight.js"></script>
        <script src="../_static/translations.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
        <script src="../_static/dark_mode_js/default_dark.js"></script>
        <script src="../_static/dark_mode_js/theme_switcher.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="表达式" href="%E8%A1%A8%E8%BE%BE%E5%BC%8F.html" />
    <link rel="prev" title="Haskell 安装与入门" href="Haskell%20%E5%AE%89%E8%A3%85%E4%B8%8E%E5%85%A5%E9%97%A8.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            TextBook
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="搜索文档" aria-label="搜索文档" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="导航菜单">
              <p class="caption" role="heading"><span class="caption-text">目录:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Haskell TextBook</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="Haskell%20%E5%AE%89%E8%A3%85%E4%B8%8E%E5%85%A5%E9%97%A8.html">Haskell 安装与入门</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">数据类型与函数</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#haskell">Haskell 类型系统特性</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id2">类型签名</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id3">强类型</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id4">静态类型</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id5">类型推导</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id6">纯度</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id7">常用数据类型</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#bool">布尔类型（Bool）</a></li>
<li class="toctree-l4"><a class="reference internal" href="#char">字符类型（Char）</a></li>
<li class="toctree-l4"><a class="reference internal" href="#int">有符号整型（Int）</a></li>
<li class="toctree-l4"><a class="reference internal" href="#word">无符号整型（Word）</a></li>
<li class="toctree-l4"><a class="reference internal" href="#integer">任意精度整数类型（Integer）</a></li>
<li class="toctree-l4"><a class="reference internal" href="#float-double">浮点数类型（Float,Double）</a></li>
<li class="toctree-l4"><a class="reference internal" href="#rational">有理数类型（Rational）</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tuple">元组（Tuple）</a></li>
<li class="toctree-l4"><a class="reference internal" href="#list">列表（List）</a></li>
<li class="toctree-l4"><a class="reference internal" href="#string">字符串类型 （String）</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id8">定义数据类型</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#algebraic-data-type">代数数据类型(Algebraic Data Type)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id9">定义别名</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id10">记录语法</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id11">新类型</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id12">定义递归类型</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id13">变量，函数与柯里化</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id14">变量？</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id15">函数与柯里化</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id16">匿名函数</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id17">运算符</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#section">节（Section）</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id18">多态</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id19">类型多态性</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id20">函数多态性</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id21">惰性</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="%E8%A1%A8%E8%BE%BE%E5%BC%8F.html">表达式</a></li>
<li class="toctree-l2"><a class="reference internal" href="%E9%80%92%E5%BD%92%E4%B8%8E%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0.html">递归与高阶函数</a></li>
<li class="toctree-l2"><a class="reference internal" href="%E7%B1%BB%E5%9E%8B%E7%B1%BB.html">类型类</a></li>
<li class="toctree-l2"><a class="reference internal" href="%E4%B8%93%E9%A2%98/%E5%87%BD%E5%AD%90%E4%B8%93%E9%A2%98.html">函子专题</a></li>
<li class="toctree-l2"><a class="reference internal" href="%E4%B8%93%E9%A2%98/Monad%E4%B8%93%E9%A2%98.html">Monad专题</a></li>
<li class="toctree-l2"><a class="reference internal" href="%E4%B8%93%E9%A2%98/IO%20%E4%B8%93%E9%A2%98.html">IO 专题</a></li>
<li class="toctree-l2"><a class="reference internal" href="Haskell%20%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F.html">Haskell 的类型系统</a></li>
<li class="toctree-l2"><a class="reference internal" href="%E4%B8%93%E9%A2%98/Typeable%20%E4%B8%93%E9%A2%98.html">Typeable 专题</a></li>
<li class="toctree-l2"><a class="reference internal" href="%E4%B8%93%E9%A2%98/GADTs%20%E4%B8%93%E9%A2%98.html">GADTs 专题</a></li>
<li class="toctree-l2"><a class="reference internal" href="%E4%B8%93%E9%A2%98/Generics%20%E4%B8%93%E9%A2%98.html">Generics 专题</a></li>
<li class="toctree-l2"><a class="reference internal" href="%E4%B8%93%E9%A2%98/%E5%B7%A5%E7%A8%8B%E4%B8%93%E9%A2%98/index.html">Haskell 工程专题</a></li>
<li class="toctree-l2"><a class="reference internal" href="%E8%B5%84%E6%BA%90.html">资源</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../logicInCS/index.html">Logic In Computer Science</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="移动版导航菜单" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">TextBook</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="页面导航">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Haskell TextBook</a></li>
      <li class="breadcrumb-item active">数据类型与函数</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/haskell/数据类型与函数.md.txt" rel="nofollow"> 查看页面源码</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="id1">
<h1>数据类型与函数<a class="headerlink" href="#id1" title="此标题的永久链接"></a></h1>
<section id="haskell">
<h2>Haskell 类型系统特性<a class="headerlink" href="#haskell" title="此标题的永久链接"></a></h2>
<section id="id2">
<h3>类型签名<a class="headerlink" href="#id2" title="此标题的永久链接"></a></h3>
<p>一个类型签名将一个名称与一个类型绑定在一起，例如上一章最末定义的<code class="docutils literal notranslate"><span class="pre">add</span></code>函数：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>Prelude&gt;:type<span class="w"> </span>add
add<span class="w"> </span>::<span class="w"> </span><span class="o">(</span>Int,<span class="w"> </span>Int<span class="o">)</span><span class="w"> </span>-&gt;<span class="w"> </span>Int
</pre></div>
</div>
</section>
<section id="id3">
<h3>强类型<a class="headerlink" href="#id3" title="此标题的永久链接"></a></h3>
<p>Haskell具有强类型系统，具体体现在该类型系统会拒绝任何无意义的表达式，也不会自动地将值从一个类型转换为另一个类型。在Haskell中遵守类型规则的表达式被称为“良类型的”(well-typed)。</p>
<p>强类型的好处在于可以在代码真正引发问题之前捕获错误<a class="reference external" href="#ref1">[1]</a>。</p>
</section>
<section id="id4">
<h3>静态类型<a class="headerlink" href="#id4" title="此标题的永久链接"></a></h3>
<p>静态类型指类型系统可以在编译的时候清楚每个值和表达式的类型，与之相对的是动态类型，其在运行时确定类型。</p>
<p>Haskell对强类型和静态类型的支持使得程序不可能发生运行时的错误，但作为代价，需要更多的努力来满足这些特性对程序代码的苛刻要求<a class="reference external" href="#ref1">[1]</a>。</p>
</section>
<section id="id5">
<h3>类型推导<a class="headerlink" href="#id5" title="此标题的永久链接"></a></h3>
<p>Haskell编译器可以自动推断出程序中近乎所有表达式的类型（偶尔需要人为提供额外的信息），这个过程被称为类型推导<a class="reference external" href="#ref1">[1]</a>。</p>
</section>
<section id="id6">
<h3>纯度<a class="headerlink" href="#id6" title="此标题的永久链接"></a></h3>
<p>如果一个函数在引用上是透明的，即不依赖于其参数以外的任何事物，则称其为纯函数或者无副作用的。纯函数对应于数学意义上的函数，在任何时间上使用相同的参数将导致相同的结果 <a class="reference external" href="#ref2">[2]</a> 。与之相对的是非纯函数或者有副作用的函数，例如含有输入输出的函数。</p>
</section>
</section>
<section id="id7">
<h2>常用数据类型<a class="headerlink" href="#id7" title="此标题的永久链接"></a></h2>
<p>Haskell中内置了许多基础且有用的类型，下面给出了部分常用的数据类型。</p>
<section id="bool">
<h3>布尔类型（Bool）<a class="headerlink" href="#bool" title="此标题的永久链接"></a></h3>
<p>布尔类型是一个只有<code class="docutils literal notranslate"><span class="pre">True</span></code>和<code class="docutils literal notranslate"><span class="pre">False</span></code>两个值的数据类型，Haskell为布尔类型提供了与<code class="docutils literal notranslate"><span class="pre">&amp;&amp;</span></code>,或<code class="docutils literal notranslate"><span class="pre">||</span></code>,非<code class="docutils literal notranslate"><span class="pre">not</span></code>三种逻辑运算。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>Prelude&gt;<span class="w"> </span>:type<span class="w"> </span>True<span class="w"> </span>
True<span class="w"> </span>::<span class="w"> </span>Bool<span class="w"> </span>
Prelude&gt;<span class="w"> </span>True<span class="w"> </span><span class="o">||</span><span class="w"> </span>False<span class="w"> </span>
True<span class="w"> </span>
Prelude&gt;<span class="w"> </span>True<span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span>False<span class="w"> </span>
False
Prelude&gt;<span class="w"> </span>not<span class="w"> </span>False
True
</pre></div>
</div>
</section>
<section id="char">
<h3>字符类型（Char）<a class="headerlink" href="#char" title="此标题的永久链接"></a></h3>
<p>字符类型是有单引号包裹的字符的类型，字符类型支持ASCII码中的所有字符，对于键盘上没有的字符可以使用反斜杠加数字表示。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>Prelude&gt;<span class="w"> </span>:type<span class="w"> </span><span class="s1">&#39;a&#39;</span>
<span class="s1">&#39;a&#39;</span><span class="w"> </span>::<span class="w"> </span>Char
Prelude&gt;<span class="w"> </span><span class="s1">&#39;\100&#39;</span><span class="w"> </span>--<span class="w"> </span>十进制表示
<span class="s1">&#39;d&#39;</span>
Prelude&gt;<span class="w"> </span><span class="s1">&#39;\o144&#39;</span><span class="w"> </span>--<span class="w"> </span>八进制表示
<span class="s1">&#39;d&#39;</span>
Prelude&gt;<span class="w"> </span><span class="s1">&#39;\x64&#39;</span><span class="w"> </span>--<span class="w"> </span>十六进制表示
<span class="s1">&#39;d&#39;</span>
</pre></div>
</div>
<p>部分特殊的ASCII码需要用反斜杠转义表达，常用的转义字符有:</p>
<table border="1" class="docutils">
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>\b</td>
<td>退格符</td>
</tr>
<tr>
<td>\n</td>
<td>换行符</td>
</tr>
<tr>
<td>\t</td>
<td>制表符</td>
</tr>
<tr>
<td>\&amp;</td>
<td>空格符</td>
</tr>
<tr>
<td>\</td>
<td>反斜杠</td>
</tr>
<tr>
<td>\"</td>
<td>双引号</td>
</tr>
<tr>
<td>\'</td>
<td>单引号</td>
</tr>
</tbody>
</table><p>除ASCII码外，Haskell也支持汉字或其他语言的字符，GHCi会返回相应的Unicode码。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>Prelude&gt;<span class="w"> </span><span class="s1">&#39;你&#39;</span>
<span class="s1">&#39;\20329&#39;</span>
</pre></div>
</div>
</section>
<section id="int">
<h3>有符号整型（Int）<a class="headerlink" href="#int" title="此标题的永久链接"></a></h3>
<p>对于64位系统，有符号整型值的范围为<span class="math notranslate nohighlight">\( -2^{63} \sim 2^{63} - 1 \)</span>。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>Prelude&gt;<span class="w"> </span><span class="m">2</span><span class="w"> </span>^<span class="w"> </span><span class="m">63</span><span class="w"> </span>-<span class="w"> </span><span class="m">1</span><span class="w"> </span>::<span class="w"> </span>Int
<span class="m">9223372036854775807</span>
Prelude&gt;<span class="w"> </span><span class="m">2</span><span class="w"> </span>^<span class="w"> </span><span class="m">63</span><span class="w"> </span>::<span class="w"> </span>Int
-9223372036854775808
Prelude&gt;<span class="w"> </span><span class="m">2</span><span class="w"> </span>^<span class="w"> </span><span class="m">64</span><span class="w"> </span>::<span class="w"> </span>Int<span class="w"> </span>
<span class="m">0</span>
</pre></div>
</div>
<p>可以看到当声明的<code class="docutils literal notranslate"><span class="pre">Int</span></code>类型值超出范围后，得到的取值是错误的。</p>
</section>
<section id="word">
<h3>无符号整型（Word）<a class="headerlink" href="#word" title="此标题的永久链接"></a></h3>
<p>对于64位系统，无符号整型值的范围为<span class="math notranslate nohighlight">\( 0 \sim 2^{64} - 1 \)</span>。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>Prelude&gt;<span class="w"> </span><span class="m">2</span><span class="w"> </span>^<span class="w"> </span><span class="m">64</span><span class="w"> </span>-<span class="w"> </span><span class="m">1</span><span class="w"> </span>::<span class="w"> </span>Word
<span class="m">18446744073709551615</span>
Prelude&gt;<span class="w"> </span><span class="m">2</span><span class="w"> </span>^<span class="w"> </span><span class="m">64</span><span class="w"> </span>::<span class="w"> </span>Word
<span class="m">18446744073709551616</span>
Prelude&gt;<span class="w"> </span><span class="m">2</span><span class="w"> </span>^<span class="w"> </span><span class="m">65</span><span class="w"> </span>::<span class="w"> </span>Word<span class="w"> </span>
<span class="m">0</span>
</pre></div>
</div>
<p>当声明的<code class="docutils literal notranslate"><span class="pre">Word</span></code>类型超出范围后，也会得到错误的值。</p>
</section>
<section id="integer">
<h3>任意精度整数类型（Integer）<a class="headerlink" href="#integer" title="此标题的永久链接"></a></h3>
<p>与Int不同，任意精度整数类型理论上可以表示任意大小的整数，在实际的计算机上，只有内存是限制其范围的因素。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>Prelude&gt;<span class="w"> </span><span class="m">2</span><span class="w"> </span>^<span class="w"> </span><span class="m">100</span>
<span class="m">1267650600228229401496703205376</span>
Prelude&gt;<span class="w"> </span><span class="m">2</span><span class="w"> </span>^<span class="w"> </span><span class="m">1000</span>
<span class="m">10715086071862673209484250490600018105614048117055336074437503883703510511249361224931983788156958581275946729175531468251871452856923140435984577574698574803934567774824230985421074605062371141877954182153046474983581941267398767559165543946077062914571196477686542167660429831652624386837205668069376</span>
</pre></div>
</div>
</section>
<section id="float-double">
<h3>浮点数类型（Float,Double）<a class="headerlink" href="#float-double" title="此标题的永久链接"></a></h3>
<p>Haskell中有单精度浮点数类型和双精度浮点数类型，这与其他语言无大差异。</p>
</section>
<section id="rational">
<h3>有理数类型（Rational）<a class="headerlink" href="#rational" title="此标题的永久链接"></a></h3>
<p>有理数类型是由两个任意精度的整数表示的（根据定义，有理数可以表示为两个整数相除）。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>Prelude&gt;<span class="w"> </span><span class="m">1</span>/3<span class="w"> </span>::<span class="w"> </span>Rational
<span class="m">1</span><span class="w"> </span>%<span class="w"> </span><span class="m">3</span><span class="w"> </span>
Prelude&gt;<span class="w"> </span><span class="m">3</span>.14<span class="w"> </span>::<span class="w"> </span>Rational
<span class="m">157</span><span class="w"> </span>%<span class="w"> </span><span class="m">50</span>
</pre></div>
</div>
</section>
<section id="tuple">
<h3>元组（Tuple）<a class="headerlink" href="#tuple" title="此标题的永久链接"></a></h3>
<p>元组是具有固定大小的一组值的集合，每个值允许有不同的类型。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>Prelude&gt;<span class="w"> </span>:type<span class="w"> </span><span class="o">(</span><span class="m">1</span>,<span class="s1">&#39;a&#39;</span><span class="o">)</span><span class="w"> </span>::<span class="w"> </span><span class="o">(</span>Int,Char<span class="o">)</span>
<span class="o">(</span><span class="m">1</span>,<span class="s1">&#39;a&#39;</span><span class="o">)</span><span class="w"> </span>::<span class="w"> </span><span class="o">(</span>Int,Char<span class="o">)</span><span class="w"> </span>::<span class="w"> </span><span class="o">(</span>Int,<span class="w"> </span>Char<span class="o">)</span>
Prelude&gt;<span class="w"> </span>:type<span class="w"> </span><span class="o">(</span><span class="m">1</span>,2,<span class="s1">&#39;c&#39;</span><span class="o">)</span><span class="w"> </span>::<span class="w"> </span><span class="o">(</span>Int,Float,Char<span class="o">)</span>
<span class="o">(</span><span class="m">1</span>,2,<span class="s1">&#39;c&#39;</span><span class="o">)</span><span class="w"> </span>::<span class="w"> </span><span class="o">(</span>Int,Float,Char<span class="o">)</span><span class="w"> </span>::<span class="w"> </span><span class="o">(</span>Int,<span class="w"> </span>Float,<span class="w"> </span>Char<span class="o">)</span>
</pre></div>
</div>
<p>Haskell还内置了两个函数<code class="docutils literal notranslate"><span class="pre">fst</span></code>和<code class="docutils literal notranslate"><span class="pre">snd</span></code>分别用于提取二元组的两个元素。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>Prelude&gt;<span class="w"> </span>fst<span class="w"> </span><span class="o">(</span><span class="m">1</span>,<span class="s1">&#39;a&#39;</span><span class="o">)</span>
<span class="m">1</span>
Prelude&gt;<span class="w"> </span>snd<span class="w"> </span><span class="o">(</span><span class="m">1</span>,<span class="s1">&#39;a&#39;</span><span class="o">)</span>
<span class="s1">&#39;a&#39;</span>
</pre></div>
</div>
</section>
<section id="list">
<h3>列表（List）<a class="headerlink" href="#list" title="此标题的永久链接"></a></h3>
<p>列表是Haskell中非常常见的数据类型，可以容纳若干相同类型的数据。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>Prelude&gt;<span class="w"> </span>:type<span class="w"> </span><span class="o">[]</span>
<span class="o">[]</span><span class="w"> </span>::<span class="w"> </span><span class="o">[</span>a<span class="o">]</span>
Prelude&gt;<span class="w"> </span>:type<span class="w"> </span><span class="o">[</span><span class="s1">&#39;h&#39;</span>,<span class="s1">&#39;e&#39;</span>,<span class="s1">&#39;l&#39;</span>,<span class="s1">&#39;l&#39;</span>,<span class="s1">&#39;o&#39;</span><span class="o">]</span>
<span class="o">[</span><span class="s1">&#39;h&#39;</span>,<span class="s1">&#39;e&#39;</span>,<span class="s1">&#39;l&#39;</span>,<span class="s1">&#39;l&#39;</span>,<span class="s1">&#39;o&#39;</span><span class="o">]</span><span class="w"> </span>::<span class="w"> </span><span class="o">[</span>Char<span class="o">]</span>
Prelude&gt;<span class="w"> </span>:type<span class="w"> </span><span class="o">[</span><span class="m">1</span>..5<span class="o">]</span><span class="w"> </span>::<span class="w"> </span><span class="o">[</span>Int<span class="o">]</span>
<span class="o">[</span><span class="m">1</span>..5<span class="o">]</span><span class="w"> </span>::<span class="w"> </span><span class="o">[</span>Int<span class="o">]</span><span class="w"> </span>::<span class="w"> </span><span class="o">[</span>Int<span class="o">]</span>
</pre></div>
</div>
<blockquote>
<div><p>好奇的读者可能发现最后一个表达式如果不添加显式声明的类型，其显式的类型签名是<code class="docutils literal notranslate"><span class="pre">[1..5]</span> <span class="pre">::</span> <span class="pre">(Num</span> <span class="pre">a,</span> <span class="pre">Enum</span> <span class="pre">a)</span> <span class="pre">=&gt;</span> <span class="pre">[a]</span></code>，这涉及到类型类的知识，将在后续章节展开。</p>
</div></blockquote>
</section>
<section id="string">
<h3>字符串类型 （String）<a class="headerlink" href="#string" title="此标题的永久链接"></a></h3>
<p>字符串类型是由若干字符组成，实际上字符串是一种特殊的列表，因此<code class="docutils literal notranslate"><span class="pre">String</span></code>和<code class="docutils literal notranslate"><span class="pre">[Char]</span></code>表述的是同一种类型，<code class="docutils literal notranslate"><span class="pre">String</span></code>只是<code class="docutils literal notranslate"><span class="pre">[Char]</span></code>的别名。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>Prelude&gt;<span class="w"> </span><span class="o">[</span><span class="s1">&#39;h&#39;</span>,<span class="s1">&#39;e&#39;</span>,<span class="s1">&#39;l&#39;</span>,<span class="s1">&#39;l&#39;</span>,<span class="s1">&#39;o&#39;</span><span class="o">]</span>
<span class="s2">&quot;hello&quot;</span>
Prelude&gt;:type<span class="w"> </span><span class="s2">&quot;hello&quot;</span>
<span class="s2">&quot;hello&quot;</span><span class="w"> </span>::<span class="w"> </span>String
</pre></div>
</div>
</section>
</section>
<section id="id8">
<h2>定义数据类型<a class="headerlink" href="#id8" title="此标题的永久链接"></a></h2>
<section id="algebraic-data-type">
<h3>代数数据类型(Algebraic Data Type)<a class="headerlink" href="#algebraic-data-type" title="此标题的永久链接"></a></h3>
<p>代数数据类型指由其他类型通过代数操作组合而成的类型，这里的代数操作指：</p>
<ul class="simple">
<li><p>和（Sum）: 假设值<code class="docutils literal notranslate"><span class="pre">x</span></code>的类型为<code class="docutils literal notranslate"><span class="pre">A</span></code>类型与<code class="docutils literal notranslate"><span class="pre">B</span></code>类型的和<code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">|</span> <span class="pre">B</span></code>，则<code class="docutils literal notranslate"><span class="pre">x</span></code>的类型要么是<code class="docutils literal notranslate"><span class="pre">A</span></code>类型，要么是<code class="docutils literal notranslate"><span class="pre">B</span></code>类型，但不能同时为<code class="docutils literal notranslate"><span class="pre">A</span></code>和<code class="docutils literal notranslate"><span class="pre">B</span></code>类型</p></li>
<li><p>积（Product）:假设值<code class="docutils literal notranslate"><span class="pre">x</span></code>的类型为<code class="docutils literal notranslate"><span class="pre">A</span></code>类型与<code class="docutils literal notranslate"><span class="pre">B</span></code>类型的积<code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">B</span></code>,则<code class="docutils literal notranslate"><span class="pre">x</span></code>是由<code class="docutils literal notranslate"><span class="pre">A</span></code>类型的值和<code class="docutils literal notranslate"><span class="pre">B</span></code>类型的值组成</p></li>
</ul>
<p>我们定义一个平面图形类型，包含了若干类别（如圆形，长方形，三角形等）。一个圆形可以由半径确定；一个长方形可以由长和宽确定；一个三角形需要给出三条边的长度才能确定。因此我们给出的定义如下：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- code1.hs</span>
<span class="kr">data</span><span class="w"> </span><span class="kt">Figure</span><span class="w"> </span><span class="ow">=</span>
<span class="w">    </span><span class="kt">Circle</span><span class="w"> </span><span class="kt">Double</span>
<span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="kt">Rectangle</span><span class="w"> </span><span class="kt">Double</span><span class="w"> </span><span class="kt">Double</span>
<span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="kt">Triangle</span><span class="w"> </span><span class="kt">Double</span><span class="w"> </span><span class="kt">Double</span><span class="w"> </span><span class="kt">Double</span><span class="w"> </span>
<span class="w">  </span><span class="kr">deriving</span><span class="w"> </span><span class="p">(</span><span class="kt">Show</span><span class="p">)</span>
</pre></div>
</div>
<p>根据代数数据类型的定义，我们可以看到，对于一个类型为<code class="docutils literal notranslate"><span class="pre">Figure</span></code>的值，它必然是圆形，长方形和三角形中之一，并由若干浮点数类型的积组成。</p>
<p>在上述的定义中，<code class="docutils literal notranslate"><span class="pre">Figure</span></code>作为类型，被称 <em><strong>类型构造器(Type Constructor)</strong></em> ; 而<code class="docutils literal notranslate"><span class="pre">Circle</span></code>,<code class="docutils literal notranslate"><span class="pre">Rectangle</span></code>,<code class="docutils literal notranslate"><span class="pre">Triangle</span></code>用于构造实际的值，被称为 <em><strong>数据构造器(Data Constructor)</strong></em> 或者 <em><strong>值构造器(Value Constructor)</strong></em><a class="reference external" href="#ref3">[3]</a>。</p>
<p>尝试构造一些值：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>Prelude&gt;<span class="w"> </span>:load<span class="w"> </span>code1.hs
<span class="o">[</span><span class="m">1</span><span class="w"> </span>of<span class="w"> </span><span class="m">2</span><span class="o">]</span><span class="w"> </span>Compiling<span class="w"> </span>Main<span class="w">             </span><span class="o">(</span><span class="w"> </span>code1.hs,<span class="w"> </span>interpreted<span class="w"> </span><span class="o">)</span>
Ok,<span class="w"> </span>one<span class="w"> </span>module<span class="w"> </span>loaded.
Prelude&gt;<span class="w"> </span>Circle<span class="w"> </span><span class="m">1</span>
Circle<span class="w"> </span><span class="m">1</span>.0
Prelude&gt;<span class="w"> </span>Rectangle<span class="w"> </span><span class="m">3</span><span class="w"> </span><span class="m">4</span>
Rectangle<span class="w"> </span><span class="m">3</span>.0<span class="w"> </span><span class="m">4</span>.0
Prelude&gt;<span class="w"> </span>:type<span class="w"> </span><span class="o">(</span>Triangle<span class="w"> </span><span class="m">3</span><span class="w"> </span><span class="m">4</span><span class="w"> </span><span class="m">5</span><span class="o">)</span>
<span class="o">(</span>Triangle<span class="w"> </span><span class="m">3</span><span class="w"> </span><span class="m">4</span><span class="w"> </span><span class="m">5</span><span class="o">)</span><span class="w"> </span>::<span class="w"> </span>Figure
</pre></div>
</div>
<blockquote>
<div><p>读者可能注意到在定义的末端使用了<code class="docutils literal notranslate"><span class="pre">deriving</span></code>派生语法，这里的作用是为了便于将值打印出来,读者可以尝试看看删去<code class="docutils literal notranslate"><span class="pre">deriving</span> <span class="pre">(Show)</span></code>后会发生什么</p>
</div></blockquote>
</section>
<section id="id9">
<h3>定义别名<a class="headerlink" href="#id9" title="此标题的永久链接"></a></h3>
<p>有的时候，我们希望类型可以表达更多的信息。例如圆形中包含了类型为浮点数的直径，但从<code class="docutils literal notranslate"><span class="pre">Circle</span> <span class="pre">Double</span></code>中我们可能并不能非常直观地看出<code class="docutils literal notranslate"><span class="pre">Double</span></code>到底指的什么。类似地，长方形和三角形也造成了同样的疑惑。</p>
<p>基于此，我们构造类型的别名，也称 <em><strong>上下文别名(Context Alias)</strong></em> <a class="reference external" href="#ref4">[4]</a>。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- code1.hs</span>
<span class="c1">-- 圆形直径</span>
<span class="kr">type</span><span class="w"> </span><span class="kt">Diameter</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Double</span>
<span class="c1">-- 长方形长宽</span>
<span class="kr">type</span><span class="w"> </span><span class="kt">Length</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Double</span>
<span class="kr">type</span><span class="w"> </span><span class="kt">Width</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Double</span>
<span class="c1">-- 三角形三条边长</span>
<span class="kr">type</span><span class="w"> </span><span class="kt">Side1</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Double</span>
<span class="kr">type</span><span class="w"> </span><span class="kt">Side2</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Double</span>
<span class="kr">type</span><span class="w"> </span><span class="kt">Side3</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Double</span>
</pre></div>
</div>
<p>这样我们就可以定义一个新的<code class="docutils literal notranslate"><span class="pre">Figure'</span></code>类型，新的定义为我们提供更多的信息。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- code1.hs</span>
<span class="kr">data</span><span class="w"> </span><span class="kt">Figure&#39;</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span>
<span class="w">  </span><span class="kt">Circle&#39;</span><span class="w"> </span><span class="kt">Diameter</span>
<span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="kt">Rectangle&#39;</span><span class="w"> </span><span class="kt">Length</span><span class="w"> </span><span class="kt">Width</span>
<span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="kt">Triangle&#39;</span><span class="w"> </span><span class="kt">Side1</span><span class="w"> </span><span class="kt">Side2</span><span class="w"> </span><span class="kt">Side3</span>
<span class="w">  </span><span class="kr">deriving</span><span class="w"> </span><span class="p">(</span><span class="kt">Show</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="id10">
<h3>记录语法<a class="headerlink" href="#id10" title="此标题的永久链接"></a></h3>
<p>通过<code class="docutils literal notranslate"><span class="pre">Figure</span></code>和<code class="docutils literal notranslate"><span class="pre">Figure'</span></code>类型定义，我们可以很容易地构造一个值，相反地，我们还希望能够从这个值里解构想要的成分。使用 <em><strong>记录语法(Record Syntax)</strong></em> ，定义中每个 <em><strong>域(field)</strong></em> 都绑定了相应解构的函数。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- code1.hs</span>
<span class="kr">data</span><span class="w"> </span><span class="kt">Figure&#39;&#39;</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span>
<span class="w">  </span><span class="kt">Circle&#39;&#39;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">getDiameter</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Diameter</span><span class="p">}</span>
<span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="kt">Rectangle&#39;&#39;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">getLength</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Length</span><span class="p">,</span><span class="w"> </span><span class="n">getWidth</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Width</span><span class="p">}</span>
<span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="kt">Triangle&#39;&#39;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">getSide1</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Side1</span><span class="p">,</span>
<span class="w">    </span><span class="n">getSide2</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Side2</span><span class="p">,</span>
<span class="w">    </span><span class="n">getSide3</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Side3</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="kr">deriving</span><span class="w"> </span><span class="p">(</span><span class="kt">Show</span><span class="p">)</span>
</pre></div>
</div>
<p>尝试验证这一点：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>Prelude&gt;<span class="w"> </span>getLength<span class="w"> </span><span class="o">(</span>Rectangle<span class="s1">&#39;&#39;</span><span class="w"> </span><span class="m">3</span><span class="w"> </span><span class="m">4</span><span class="o">)</span><span class="w"> </span>
<span class="m">3</span>.0
Prelude&gt;<span class="w"> </span>getSide1<span class="w"> </span>Triangle<span class="s1">&#39;&#39;</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="nv">getSide1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">3</span><span class="w"> </span>,<span class="w"> </span><span class="nv">getSide2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">4</span><span class="w"> </span>,<span class="w"> </span><span class="nv">getSide3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">5</span><span class="o">}</span>
<span class="m">3</span>.0
</pre></div>
</div>
</section>
<section id="id11">
<h3>新类型<a class="headerlink" href="#id11" title="此标题的永久链接"></a></h3>
<p><em><strong>新类型(Newtype)</strong></em> <code class="docutils literal notranslate"><span class="pre">newtype</span></code>的创建方法与<code class="docutils literal notranslate"><span class="pre">data</span></code>声明类型的方法大致相同，但比较受限，只有当类型由一个构造函数且只有一个字段时，才可以使用<code class="docutils literal notranslate"><span class="pre">newtype</span></code>。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- code1.hs</span>
<span class="kr">newtype</span><span class="w"> </span><span class="kt">NewInt</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">NewInt</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span>
<span class="kr">newtype</span><span class="w"> </span><span class="kt">NewInt&#39;</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">NewInt&#39;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">getInt</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
<blockquote>
<div><p>看起来<code class="docutils literal notranslate"><span class="pre">newtype</span></code>并不如<code class="docutils literal notranslate"><span class="pre">data</span></code>好用，但对于编译器来说却有帮助，<code class="docutils literal notranslate"><span class="pre">newtype</span></code>的限制实际上意味着新类型与原类型是同构的，这样在编译时检查类型后，在运行时这两个类型被视为相同的<a class="reference external" href="#ref5">[5]</a>。</p>
</div></blockquote>
</section>
<section id="id12">
<h3>定义递归类型<a class="headerlink" href="#id12" title="此标题的永久链接"></a></h3>
<p>Haskell允许以递归地形式定义数据类型，一个最典型的例子就是自然数的定义：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- code1.hs</span>
<span class="kr">data</span><span class="w"> </span><span class="kt">Nat</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Zero</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">Succ</span><span class="w"> </span><span class="kt">Nat</span><span class="w"> </span><span class="kr">deriving</span><span class="w"> </span><span class="p">(</span><span class="kt">Show</span><span class="p">)</span>
</pre></div>
</div>
<p>一个自然数要么为零，要么为另一个自然数的后继，对于后者，定义中调用了类型本身。</p>
<p>通过上述递归定义，我们就可以构造自然数了：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>Prelude&gt;<span class="w"> </span>Zero<span class="w"> </span>--<span class="w"> </span><span class="m">0</span>
Zero
Prelude&gt;<span class="w"> </span>Succ<span class="w"> </span><span class="o">(</span>Succ<span class="w"> </span>Nat<span class="o">)</span><span class="w"> </span>--<span class="w"> </span><span class="m">2</span>
Succ<span class="w"> </span><span class="o">(</span>Succ<span class="w"> </span>Nat<span class="o">)</span><span class="w"> </span>
</pre></div>
</div>
</section>
</section>
<section id="id13">
<h2>变量，函数与柯里化<a class="headerlink" href="#id13" title="此标题的永久链接"></a></h2>
<section id="id14">
<h3>变量？<a class="headerlink" href="#id14" title="此标题的永久链接"></a></h3>
<p>在Haskell中，变量有两种指代，一种是函数中的形参，另一种则是主流编程语言中所指的变量。对于后者，Haskell中的变量徒有其名（不如称其为常量），因为一旦给定变量以值（如<code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">2</span></code>），该变量就不会在运行时改变<a class="reference external" href="#ref6">[6]</a>。</p>
</section>
<section id="id15">
<h3>函数与柯里化<a class="headerlink" href="#id15" title="此标题的永久链接"></a></h3>
<p>Haskell中的函数非常贴近数学意义上的函数，它将一个（或者一组）类型的值映射到另一个（或者一组）类型的值。</p>
<blockquote>
<div><p>补充：关于一组类型的映射需要用到类型类，将在后面讲解，这里可以认为由一个类型到另一个类型的映射</p>
</div></blockquote>
<p>在前面已经给过一个函数的例子–整数加法：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- code1.hs</span>
<span class="nf">add</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="kt">Int</span><span class="p">,</span><span class="w"> </span><span class="kt">Int</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span>
<span class="nf">add</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="w"> </span>
</pre></div>
</div>
<p>然而在Haskell中这样的函数并不常见，通常我们使用 <em><strong>柯里化(Currying)</strong></em> 的函数。柯里化是将一个函数转化为另一个函数的过程，具体为将参数元组拆分，形成新的函数，该函数可以依次接受对应于原函数元组对应位置的参数<a class="reference external" href="#ref7">[7]</a>，也就是说每次接受一个参数。</p>
<p>整数加法的函数柯里化后：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- code1.hs</span>
<span class="nf">add&#39;</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span>
<span class="nf">add&#39;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span>
</pre></div>
</div>
<p>柯里化后的函数使用起来更加方便，因为这使得 <em><strong>部分应用(Partial Application)</strong></em> 变得轻而易举，例如：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- code1.hs</span>
<span class="nf">addone</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span>
<span class="nf">addone</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">add&#39;</span><span class="w"> </span><span class="mi">1</span>
<span class="c1">-- addone = add&#39; 1 ? = 1 + ?</span>
</pre></div>
</div>
<p>我们通过将<code class="docutils literal notranslate"><span class="pre">add'</span></code>函数应用到数字1上，得到了一个新的函数（新的函数称为部分函数或者偏函数），这个函数对参数增加一。</p>
<p>另外，不难发现，柯里化的函数类型中箭头是右结合的，即<code class="docutils literal notranslate"><span class="pre">add'</span></code>函数的类型是<code class="docutils literal notranslate"><span class="pre">Int</span> <span class="pre">-&gt;</span> <span class="pre">(Int</span> <span class="pre">-&gt;</span> <span class="pre">Int)</span></code>。</p>
</section>
</section>
<section id="id16">
<h2>匿名函数<a class="headerlink" href="#id16" title="此标题的永久链接"></a></h2>
<p><em><strong>匿名函数(Anonymous function)</strong></em> 是一个不带有名字的函数，在某些情况下我们使用匿名函数更为方便（我们将在后续章节中大量使用匿名函数）。</p>
<p>匿名函数是一个 <em><strong><span class="math notranslate nohighlight">\( \lambda \)</span>抽象(Lambda Abstraction)</strong></em> <a class="reference external" href="#ref8">[8]</a>，书写模式类似<code class="docutils literal notranslate"><span class="pre">\</span> <span class="pre">参数1</span> <span class="pre">参数2</span> <span class="pre">...</span> <span class="pre">-&gt;</span> <span class="pre">表达式</span></code>。</p>
<blockquote>
<div><p>提示： 读者可以查阅lambda演算资料了解更多</p>
</div></blockquote>
<p>将上面的加法用匿名函数重写：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- code1.hs</span>
<span class="nf">add&#39;</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span>
<span class="nf">add&#39;</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="nf">\</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span>

<span class="nf">addone&#39;</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span>
<span class="nf">addone&#39;</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="mi">1</span>
<span class="c1">-- 等同于</span>
<span class="nf">addone&#39;&#39;</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span>
<span class="nf">addone&#39;&#39;</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="nf">\</span><span class="n">y</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span>
</pre></div>
</div>
</section>
<section id="id17">
<h2>运算符<a class="headerlink" href="#id17" title="此标题的永久链接"></a></h2>
<p>虽然我们很容易地定义了加法，但这与我们在平时使用的加法符号还有些差距。首先，它不是中缀的；其次它是由字母组成的而非符号。</p>
<p>对于前者，Haskell提供了一种将二元函数两边添加反单引号的方式，这将二元函数解析为中缀的。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>Prelude&gt; 1 `add&#39;` 2
3
</pre></div>
</div>
<p>使用中缀表达可以提高程序的可读性，但有时为了方便，我们还会定义运算符。从原理上，运算符就是函数，但增加了一些规则–优先级(Precedence)、结合性(associativity)、位置(Fixity)。</p>
<p>在Haskell中，运算符优先级由<span class="math notranslate nohighlight">\( 0 \sim 9 \)</span>十个整数组成,结合性分为左结合性、右结合性、无结合性，位置分为前缀和中缀（这里着重讲中缀）。</p>
<p>我们定义一个运算符<code class="docutils literal notranslate"><span class="pre">|+|</span></code>用于计算加法：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- code1.hs</span>
<span class="p">(</span><span class="o">|+|</span><span class="p">)</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span>
<span class="p">(</span><span class="o">|+|</span><span class="p">)</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span>

<span class="kr">infixl</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="o">|+|</span>
</pre></div>
</div>
<p>上述代码中，定义了加法是左结合的中缀运算符，优先级为6。</p>
<p>类似地，再定义一个运算符<code class="docutils literal notranslate"><span class="pre">|*|</span></code>用于计算乘法：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- code1.hs</span>
<span class="p">(</span><span class="o">|*|</span><span class="p">)</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span>
<span class="nf">x</span><span class="w"> </span><span class="o">|*|</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">y</span>

<span class="kr">infixl</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="o">|*|</span>
</pre></div>
</div>
<p>乘法也是左结合的，但优先级为7，比加法结合地更紧密。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>Prelude&gt;<span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="p">|</span>+<span class="p">|</span><span class="w"> </span><span class="m">2</span>
<span class="m">3</span>
Prelude&gt;<span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="p">|</span>*<span class="p">|</span><span class="w"> </span><span class="m">2</span>
<span class="m">2</span>
Prelude&gt;<span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="p">|</span>+<span class="p">|</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="p">|</span>*<span class="p">|</span><span class="w"> </span><span class="m">2</span>
<span class="m">5</span>
</pre></div>
</div>
<blockquote>
<div><p>提示：前面讲到运算符实际上就是函数，因此它当然可以以前缀的方式使用，如<code class="docutils literal notranslate"><span class="pre">(|+|)</span> <span class="pre">1</span> <span class="pre">2</span></code></p>
</div></blockquote>
<section id="section">
<h3>节（Section）<a class="headerlink" href="#section" title="此标题的永久链接"></a></h3>
<p>对于中缀运算符，Haskell提供了一种构造部分函数的简洁方法– <em><strong>节(Section)</strong></em> 。</p>
<p>考虑前面的“增一”函数，我们已经有了<code class="docutils literal notranslate"><span class="pre">addone</span></code>,<code class="docutils literal notranslate"><span class="pre">adone'</span></code>和<code class="docutils literal notranslate"><span class="pre">addone''</span></code>三个版本的写法，实际上使用节将比上述方法更简洁。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- code1.hs</span>
<span class="nf">addone&#39;&#39;&#39;</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span>
<span class="nf">addone&#39;&#39;&#39;</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="p">)</span>
</pre></div>
</div>
<p>从本质上来说，节相当于给中缀运算符提供其中的一个参数，得到一个函数，该函数接受一个参数放到中缀运算符缺失的位置上<a class="reference external" href="#ref9">[9]</a>。</p>
<blockquote>
<div><p>提示：实际上，节对具有中缀特性的表达都有效，比如<code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">`add'`</span></code>也是一个合法的表达式。</p>
</div></blockquote>
</section>
</section>
<section id="id18">
<h2>多态<a class="headerlink" href="#id18" title="此标题的永久链接"></a></h2>
<p>通俗来讲，<em><strong>多态性(PolyMorphism)</strong></em> 就是指类型中支持变量的特性。一般地，Haskell大多数多态都属于两类之一：<em><strong>参数多态性(Parametric PolyMorphism)</strong></em> 和 <em><strong>临时多态性(Ad-hoc PolyMorphism)</strong></em> <a class="reference external" href="#ref10">[10]</a>。这里主要讨论前者，而将后者放到类型类的部分讲解。</p>
<p>参数多态性中类型中的变量是任意类型，因此也就可以被任意实际的类型替代。我们将从类型多态性和函数多态性分别讲解参数多态性。</p>
<section id="id19">
<h3>类型多态性<a class="headerlink" href="#id19" title="此标题的永久链接"></a></h3>
<p>类型多态性，顾名思义就是类型中含有变量，在前面的讲解中，我们已经或多或少接触到了具有多态性的类型，一个非常熟悉的例子就是列表类型。</p>
<p>列表是Haskell的内置类型，我们通过GHCi输入<code class="docutils literal notranslate"><span class="pre">:info</span> <span class="pre">[]</span></code>即可查看列表的定义。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">[]</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">[]</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span>
</pre></div>
</div>
<p>这是一个递归定义的类型，它定义了两种情形：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[]</span></code>: 空列表，列表中不包含任何元素</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">:</span> <span class="pre">[a]</span></code>: 非空列表，则必然表达为一个元素附加到另一个同类型列表的头部</p></li>
</ul>
<p>这里面<code class="docutils literal notranslate"><span class="pre">a</span></code>就是一个类型变量，当我们用特定类型的值构造一个列表时，变量<code class="docutils literal notranslate"><span class="pre">a</span></code>就被赋予了所对应的类型。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>Prelude&gt;<span class="w"> </span>:type<span class="w"> </span><span class="o">[]</span>
<span class="o">[]</span><span class="w"> </span>::<span class="w"> </span><span class="o">[</span>a<span class="o">]</span>
Prelude&gt;<span class="w"> </span>:type<span class="w"> </span><span class="o">[</span><span class="s1">&#39;a&#39;</span>,<span class="s1">&#39;b&#39;</span>,<span class="s1">&#39;c&#39;</span><span class="o">]</span>
<span class="o">[</span><span class="s1">&#39;a&#39;</span>,<span class="s1">&#39;b&#39;</span>,<span class="s1">&#39;c&#39;</span><span class="o">]</span><span class="w"> </span>::<span class="w"> </span><span class="o">[</span>Char<span class="o">]</span>
Prelude&gt;<span class="w"> </span>:type<span class="w"> </span><span class="o">[</span><span class="m">1</span>,2,3<span class="o">]</span><span class="w"> </span>::<span class="w"> </span><span class="o">[</span>Int<span class="o">]</span>
<span class="o">[</span><span class="m">1</span>,2,3<span class="o">]</span><span class="w"> </span>::<span class="w"> </span><span class="o">[</span>Int<span class="o">]</span><span class="w"> </span>::<span class="w"> </span><span class="o">[</span>Int<span class="o">]</span>
</pre></div>
</div>
<blockquote>
<div><p>提示：
1.根据定义，我们当然可以使用值构造器构造想要的列表（比如<code class="docutils literal notranslate"><span class="pre">1:2:3:[]</span></code>），这在Haskell中是理所当然的，而使用<code class="docutils literal notranslate"><span class="pre">[1,2,3]</span></code>的写法则是内置的 <em><strong>语法糖(syntactic sugar)</strong></em>
2.在列表的定义中，<code class="docutils literal notranslate"><span class="pre">:</span></code>作为值构造器实际上还是运算符，在GHCi中使用<code class="docutils literal notranslate"><span class="pre">:info</span> <span class="pre">(:)</span></code>命令可以看到<code class="docutils literal notranslate"><span class="pre">infixr</span> <span class="pre">5</span> <span class="pre">:</span></code>，也就是说这个构造器是右结合的中缀运算符，这也解释了为什么<code class="docutils literal notranslate"><span class="pre">1:2:3:[]</span></code>不用使用括号来避免歧义</p>
</div></blockquote>
<blockquote>
<div><p>补充：看起来值构造器<code class="docutils literal notranslate"><span class="pre">:</span></code>就像一个函数，在GHCi中也可以查看到它的类型为<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">[a]</span> <span class="pre">-&gt;</span> <span class="pre">[a]</span></code>，但实际上两者还是有差异的，具体表现在函数无法进行模式匹配上（后面章节会讲解）</p>
</div></blockquote>
<p>另一个内置且常用的多态类型是<code class="docutils literal notranslate"><span class="pre">Maybe</span></code>类型，<code class="docutils literal notranslate"><span class="pre">Maybe</span></code>类型常常用于可能存在无意义输出的情形下，其定义如下：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">Maybe</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Nothing</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">Just</span><span class="w"> </span><span class="n">a</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Maybe</span></code>类型包含两种情形，第一种是<code class="docutils literal notranslate"><span class="pre">Nothing</span></code>表示无意义，第二种是<code class="docutils literal notranslate"><span class="pre">Just</span> <span class="pre">a</span></code>表示有意义并包含了实际的结果。</p>
<p>给定两个整数，计算两个数整除的结果，就是一个典型应用<code class="docutils literal notranslate"><span class="pre">Maybe</span></code>类型的例子，当除数为0时，我们可以让其返回<code class="docutils literal notranslate"><span class="pre">Nothing</span></code>，而当除数非0时，使用<code class="docutils literal notranslate"><span class="pre">Just</span></code>包含得到的商。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- code1.hs</span>
<span class="nf">divide</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Maybe</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span>
<span class="nf">divide</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">if</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="kt">Nothing</span><span class="w"> </span><span class="kr">else</span><span class="w"> </span><span class="kt">Just</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="p">`</span><span class="n">div</span><span class="p">`</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w">  </span>
</pre></div>
</div>
<blockquote>
<div><p>提示： 这里使用了<code class="docutils literal notranslate"><span class="pre">if-then-else</span></code>表达式，在下一章“表达式”将会着重讲解。</p>
</div></blockquote>
</section>
<section id="id20">
<h3>函数多态性<a class="headerlink" href="#id20" title="此标题的永久链接"></a></h3>
<p>函数多态性，即函数的类型中含有变量，这些变量可以被实际的任意类型替代。这里我们以<code class="docutils literal notranslate"><span class="pre">id</span></code>和<code class="docutils literal notranslate"><span class="pre">(.)</span></code>两个基础的函数作为例子。</p>
<p><code class="docutils literal notranslate"><span class="pre">id</span></code>函数称为身份函数或单位映射，这个函数非常简单但是看起来“没什么意义”。<code class="docutils literal notranslate"><span class="pre">id</span></code>函数接受任意类型的值，并返回值本身。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">id</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span>
<span class="nf">id</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span>
</pre></div>
</div>
<blockquote>
<div><p>提示：实际上，“没什么意义”却有意义，在函数作为一等公民的语言中，身份函数就像0和1对其他语言一种重要</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">(.)</span></code>函数是一个复合运算的运算符，可以将若干的函数复合起来，形成新的函数。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="o">.</span><span class="p">)</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">c</span>
<span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">g</span><span class="p">)</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="n">g</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>

<span class="kr">infixr</span><span class="w"> </span><span class="mi">9</span><span class="w"> </span><span class="o">.</span>
</pre></div>
</div>
<p>不难发现，将复合运算作为一个二元运算，则<code class="docutils literal notranslate"><span class="pre">id</span></code>函数与任意函数的复合都是函数本身; 另外，复合运算对于函数还满足结合律，即<code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">.</span> <span class="pre">g</span> <span class="pre">.</span> <span class="pre">h</span></code>和<code class="docutils literal notranslate"><span class="pre">(f</span> <span class="pre">.</span> <span class="pre">g)</span> <span class="pre">.</span> <span class="pre">h</span></code>是相等的，这一点可以通过推导二者的类型得到。</p>
</section>
</section>
<section id="id21">
<h2>惰性<a class="headerlink" href="#id21" title="此标题的永久链接"></a></h2>
<p>惰性或者 <em><strong>惰性求值(Lazy Evaluation)</strong></em> 指的是当表达式绑定到变量时， 不会立刻进行计算，而是会延迟直到其他计算需要时才会计算结果<a class="reference external" href="#ref11">[11]</a>。</p>
<p>在Haskell中，惰性求值是默认的，我们可以验证这一点：</p>
<ul class="simple">
<li><p>示例1：</p></li>
</ul>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>Prelude&gt;<span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">[</span><span class="m">1</span>..<span class="o">]</span>
Prelude&gt;<span class="w"> </span>head<span class="w"> </span>x
<span class="m">1</span>
</pre></div>
</div>
<p>我们可以给变量<code class="docutils literal notranslate"><span class="pre">x</span></code>赋值一个无穷列表<code class="docutils literal notranslate"><span class="pre">[1..]</span></code>,这是一个自然数数列<code class="docutils literal notranslate"><span class="pre">{1,2,...}</span></code>，对于严格求值的语言来说，这是不可能实现的，因为无穷的自然数将会耗尽计算机的存储资源进而宕机；然而对于Haskell来说，计算无穷列表并不是必要的，因此赋值过程并没有对无穷列表求值，可以非常顺利地进行；接下来我们使用<code class="docutils literal notranslate"><span class="pre">head</span></code>函数获取<code class="docutils literal notranslate"><span class="pre">x</span></code>中的第一个元素，<code class="docutils literal notranslate"><span class="pre">head</span></code>函数首先会分析<code class="docutils literal notranslate"><span class="pre">x</span></code>为非空列表，根据定义必然可以表示为<code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">:</span> <span class="pre">[2..]</span></code>，而<code class="docutils literal notranslate"><span class="pre">1</span></code>即为所求，直接返回<code class="docutils literal notranslate"><span class="pre">1</span></code>即可，<code class="docutils literal notranslate"><span class="pre">[2..]</span></code>因为无需计算而没有被求值。</p>
<blockquote>
<div><p>补充：<code class="docutils literal notranslate"><span class="pre">[1..]</span></code> 也是一种语法糖，称为列表推导式，其他的例子如<code class="docutils literal notranslate"><span class="pre">[0.5..3.5]</span></code>表示<code class="docutils literal notranslate"><span class="pre">[0.5,1.5,2.5,3.5]</span></code>,另外也可以用字符作为元素如<code class="docutils literal notranslate"><span class="pre">['a'..'c']</span></code>表示<code class="docutils literal notranslate"><span class="pre">&quot;abc&quot;</span></code>。</p>
</div></blockquote>
<ul class="simple">
<li><p>示例2：</p></li>
</ul>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>Prelude&gt;<span class="w"> </span><span class="nv">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span><span class="w"> </span>:<span class="w"> </span>z
Prelude&gt;<span class="w"> </span>head<span class="w"> </span>z
<span class="m">1</span>
</pre></div>
</div>
<p>示例2定义了一个无限循环的列表<code class="docutils literal notranslate"><span class="pre">[1,1,...]</span></code>,类似地，我们也可以借助惰性求值的特性获得列表的头部元素。</p>
<ul class="simple">
<li><p>示例3：</p></li>
</ul>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>Prelude&gt;<span class="w"> </span><span class="nv">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">[</span><span class="m">1</span>,2,undefined<span class="o">]</span>
Prelude&gt;<span class="w"> </span>head<span class="w"> </span>y
<span class="m">1</span>
</pre></div>
</div>
<p>示例3中，<code class="docutils literal notranslate"><span class="pre">y</span></code>被赋予了含有未定义的元素，由于惰性求值的特性，赋值过程和<code class="docutils literal notranslate"><span class="pre">head</span> <span class="pre">y</span></code>并没有因为未定义的元素而产生错误。</p>
<p>由此可以看到惰性下的延迟计算带来了很多优点，这种语义允许人们绕过未定义的值或者处理无穷的数据<a class="reference external" href="#ref11">[11]</a>。</p>
<blockquote>
<div><p>补充：然而惰性并不是完全没有代价的，因为不立即求值，所以必须要保留未计算的表达式，这也会导致内存的使用变得难以预测<a class="reference external" href="#ref11">[11]</a></p>
</div></blockquote>
<hr class="docutils" />
<p id="ref1">[1] O’Sullivan, B., Goerzen, J., & Stewart, D. (2008). Real World Haskell (1st ed.). O’Reilly Media, Inc.
</p>
<p id="ref2">[2] Pure. (2021, November 5). HaskellWiki, . Retrieved 11:54, March 8, 2024 from https://wiki.haskell.org/index.php?title=Pure&oldid=64830.</p>
<p id="ref3">[3] Algebraic data type. (2023, May 22). HaskellWiki, . Retrieved 11:12, March 10, 2024 from https://wiki.haskell.org/index.php?title=Algebraic_data_type&oldid=65617.</p>
<p id="ref4">[4] Context alias. (2021, July 24). HaskellWiki, . Retrieved 11:31, March 10, 2024 from https://wiki.haskell.org/index.php?title=Context_alias&oldid=64617.</p>
<p id="ref5">[5] Newtype. (2016, May 22). HaskellWiki, . Retrieved 12:55, March 10, 2024 from https://wiki.haskell.org/index.php?title=Newtype&oldid=60788.</p>
<p id="ref6">[6] Variable. (2006, October 11). HaskellWiki, . Retrieved 14:05, March 10, 2024 from https://wiki.haskell.org/index.php?title=Variable&oldid=6880.</p>
<p id="ref7">[7] Currying. (2023, November 3). HaskellWiki, . Retrieved 14:53, March 10, 2024 from https://wiki.haskell.org/index.php?title=Currying&oldid=66401.</p>
<p id="ref8">[8] Anonymous function. (2021, April 12). HaskellWiki, . Retrieved 02:09, March 11, 2024 from https://wiki.haskell.org/index.php?title=Anonymous_function&oldid=64188.</p>
<p id="ref9">[9] Section of an infix operator. (2017, March 31). HaskellWiki, . Retrieved 03:54, March 11, 2024 from https://wiki.haskell.org/index.php?title=Section_of_an_infix_operator&oldid=61678.</p>
<p id="ref10">[10] Polymorphism. (2015, January 21). HaskellWiki, . Retrieved 08:40, March 11, 2024 from https://wiki.haskell.org/index.php?title=Polymorphism&oldid=59216.</p>
<p id="ref11">[11] Lazy evaluation. (2021, February 6). HaskellWiki, . Retrieved 13:33, March 11, 2024 from https://wiki.haskell.org/index.php?title=Lazy_evaluation&oldid=63958.</p></section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="页脚">
        <a href="Haskell%20%E5%AE%89%E8%A3%85%E4%B8%8E%E5%85%A5%E9%97%A8.html" class="btn btn-neutral float-left" title="Haskell 安装与入门" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> 上一页</a>
        <a href="%E8%A1%A8%E8%BE%BE%E5%BC%8F.html" class="btn btn-neutral float-right" title="表达式" accesskey="n" rel="next">下一页 <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; 版权所有 2024, Alfred Xiang.</p>
  </div>

  利用 <a href="https://www.sphinx-doc.org/">Sphinx</a> 构建，使用的 
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">主题</a>
    由 <a href="https://readthedocs.org">Read the Docs</a> 开发.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>