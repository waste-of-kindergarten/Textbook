# 类型类

在 *数据类型与函数* 一章中，我们阐述了多态性分为 ***参数多态性(Parametric PolyMorphism)*** 和 ***临时多态性(Ad-hoc PolyMorphism)*** ， 并着重讨论了参数多态性。本章我们讲解的类型类，是一种允许使用临时多态性的语法。

临时多态性允许某个变量为若干类型中的任意一种，这是因为它对于每种类型都进行了单独的定义[[1]](#ref1)。

> 提示：与参数多态性明显不同的是，参数多态性中类型的变量指任意类型，而临时多态性的类型并不是任意的。

## 类型类的声明与实例的实现

仍然沿用`Figure''`类型，并定义一个`SolidFigure`类型表示立体图形。

```hs
-- code4.hs
{-# LANGUAGE DuplicateRecordFields #-}
-- 开启扩展 DuplicateRecordFields 允许记录语法中的域名称重复
type Height = Double

data SolidFigure = 
    Sphere {getDiameter :: Diameter}
    | Cuboid {getLength :: Length, getWidth :: Width, getHeight :: Height}
    | Cylinder {getDiameter :: Diameter, getHeight :: Height}
    deriving (Show)
```

`SolidFigure`类型定义了三个立体图形，`Sphere`表示球体，`Cuboid`为长方体，`Cylinder`为圆柱体，当然还有其他立体图形，读者可以根据自己的喜好自行添加。

在前面章节中我们定义过的`judgeShape`函数，它可以用于判断`Figure''`类型的形状，我们希望定义一个更通用的函数，它既可以判断平面图形`Figure''`也可以判断立体图形`SolidFigure`。类型类恰好就可以胜任这种情形。

我们定义一个`Judgeable`类型类用来表示图形是可判断的，如下：

```hs
-- code4.hs
class Judgeable a where 
    judgeType :: a -> String
    tellShape :: a -> String
```

类型类以`class`关键字开头，并定义了两个函数`judgeType`和`tellShape`用于判断图形的类型和图形的形状。

此时，我们已经构建了具有临时多态性的函数，接下来只需要分别对两种待处理的类型进行实例化。

```hs
-- code4.hs
-- {-# LANGUAGE InstanceSigs #-}

instance Judgeable Figure'' where  
    -- judgeType :: Figure'' -> String
    judgeType _ = "A Figure"
    -- tellShape :: Figure'' -> String
    tellShape (Circle'' _) = "A Circle"
    tellShape (Rectangle'' {}) = "A Rectangle"
    tellShape (Triangle'' {}) = "A Triangle"

instance Judgeable SolidFigure where 
    -- judgeType :: SolidFigure -> String
    judgeType _ = "A SolidFigure"
    -- tellShape :: SolidFigure -> String
    tellShape (Sphere _) = "A Sphere"
    tellShape (Cuboid {}) = "A Cuboid"
    tellShape (Cylinder {}) = "A Cylinder"
```

使用关键字`instance`将类型类`Judgeable`中参数`a`实例化为对应类型，并为实例定义相应的函数。

> 注意：在Haskell 2010标准中，类型类实例中默认不允许使用类型签名，可以使用扩展 `{-# LANGUAGE InstanceSigs #-}`允许这一点，这在后续的标准中已经被移除

下面尝试在GHCi中使用这个类型类：

```bash
Prelude> :load code4.hs
[1 of 1] Compiling Main             ( code4.hs, interpreted )
Ok, one module loaded.
Prelude> tellShapeInfo x = "This is " ++ tellShape x ++ " which is " ++ judgeType x
Prelude> tellShapeInfo (Sphere 1)
"This is A Sphere which is A SolidFigure"
Prelude> tellShapeInfo (Circle'' 1)
"This is A Circle which is A Figure"
```

## 常用类型类

Haskell中内置了众多的类型类，由于这些类型类可以自动派生出实例，本小结仅对这些类型类进行简要的介绍。对于希望了解手动定义的读者可以在本章末尾查看有关常用类型类实现的示例。

### 相等类型类 `Eq`

`Eq`类型类提供了判断相等（不等）的函数，其定义如下：

```hs
class Eq a where
  (==) :: a -> a -> Bool
  (/=) :: a -> a -> Bool
  {-# MINIMAL (==) | (/=) #-} 
```

`Eq`类型类中`(==)`函数用于判断相等，而`(/=)`用于判断不等。根据尾行的提示，在对类型类进行实例化时，只需要实现`(==)`和`(/=)`中的一个即可（最小实现）。

### 有序类型类 `Ord`

`Ord`类型类用于实现排序相关的函数，一个能够排序的类型必然是能够判断相等的（或者说受到相等性约束），因此在实现`Ord`类型类实例时，必须首先实现`Eq`的实例。

```hs
class Eq a => Ord a where
  compare :: a -> a -> Ordering
  (<) :: a -> a -> Bool
  (<=) :: a -> a -> Bool
  (>) :: a -> a -> Bool
  (>=) :: a -> a -> Bool
  max :: a -> a -> a
  min :: a -> a -> a
  {-# MINIMAL compare | (<=) #-}
```

`Ord`类型类中内置了许多函数，但根据尾行提示，只需要实现`compare`函数或者`(<=)`函数即可，其他函数可以根据用户实现的函数和`Eq`类型类的约束导出。

### 有界类型类 `Bounded`

有界类型类比较简单，用于为类型提供一个最小值和最大值。

```hs
class Bounded a where
  minBound :: a
  maxBound :: a
  {-# MINIMAL minBound, maxBound #-}
```

`Bounded`类型类的实例需要对两个函数全部实现。

### 枚举类型类 `Enum`

`Enum`类型类定义如下：

```hs
class Enum a where
  succ :: a -> a
  pred :: a -> a
  toEnum :: Int -> a
  fromEnum :: a -> Int
  enumFrom :: a -> [a]
  enumFromThen :: a -> a -> [a]
  enumFromTo :: a -> a -> [a]
  enumFromThenTo :: a -> a -> a -> [a]
  {-# MINIMAL toEnum, fromEnum #-}
```

一般地，只需要定义`toEnum`和`fromEnum`即可实现枚举类型的实例，这两个函数将实例中实现的类型与整数做了一一对应。

> 提示： 前面使用过的语法糖`..`(如`[1..5]`表示`[1,2,3,4,5]`)就是依靠`Enum`类型类实现的，只要一个类型被实现为`Enum`的实例，就可以使用`..`生成一个枚举列表。

### 索引类型类 `Ix`

`Ix`类型类为离散有序的类型提供索引，定义如下：

```hs
class Ord a => Ix a where
  range :: (a, a) -> [a]
  index :: (a, a) -> a -> Int
  GHC.Arr.unsafeIndex :: (a, a) -> a -> Int
  inRange :: (a, a) -> a -> Bool
  rangeSize :: (a, a) -> Int
  GHC.Arr.unsafeRangeSize :: (a, a) -> Int
  {-# MINIMAL range, (index | unsafeIndex), inRange #-}
```

`Ix`类型类的最小实现为`range`，`index`和`unsafeIndex`之一，以及`inRange`函数。其中`range`函数接受一个二元组（左边应当小于右边），并返回一个以元组元素为范围列表（包含元组中的两个元素）；`index`函数用于检索某个元素位于元组标示的范围的位置,当检索元素不再范围内时会报错； `unsafeIndex`是`index`不会报错的版本，但无法保证元素是否在范围内；`inRange`则判断元素是否在范围内。其余函数根据名称和类型签名也不难判断其含义。

### 可显示类型类 `Show`

在Haskell中，不是所有类型“天生”就可以输出到终端上的，这需要通过实现`Show`类型类的实例来完成。

```hs
class Show a where
  showsPrec :: Int -> a -> ShowS
  show :: a -> String
  showList :: [a] -> ShowS
  {-# MINIMAL showsPrec | show #-}
```

为了能够显示某个类型的值，可以选择实现`show`函数或者`showsPrec`函数，其中`showsPrec`函数返回的类型`ShowS`实际上是`String -> String`的别名。

### 可读类型类 `Read`

`Read`类型类与`Show`类型类可以认为是互为相反的操作，其将字符串转换为特定类型的值。

```hs
class Read a where
  readsPrec :: Int -> ReadS a
  readList :: ReadS [a]
  GHC.Read.readPrec :: Text.ParserCombinators.ReadPrec.ReadPrec a
  GHC.Read.readListPrec :: Text.ParserCombinators.ReadPrec.ReadPrec
                             [a]
  {-# MINIMAL readsPrec | readPrec #-}
```

这里只介绍一个常用的必要实现函数`readsPrec`，其接受的`Int`参数为构造器的优先级（函数应用的优先级为10），返回类型中的`ReadS a`是`String -> [(a,String)]`的别称。

### 字符串类型类 `IsString`

`IsString`类型类位于`Data.String`模块。在实际编程中，默认的字符串String类型某些操作效率不高（单向链表），因此Haskell还提供了诸如ByteString、Text等类型，因此有时需要将String与其他存储字符串的类型进行转换，这是就需要用到`IsString`类型类。

> 补充： ByteString通过Word8数组存储字符串，Text将ByteString编码为如ASCII,UTF8等标准格式。

```hs
class IsString a where
  fromString :: String -> a
  {-# MINIMAL fromString #-}
```

> 提示： 一般情况下，可以使用`{-# LANGUAGE OverloadedStrings #-}`让不同“字符串”之间进行转换。


### 函子类型类 (`Functor`, `Applicative`, `Monad`)

三种函子类型类虽然是常见的类型类，但其比较复杂（涉及到范畴相关的知识），因此我们将其单独书写为一章<a>函子教程专题</a>,读者可以选择详细了解三种函子类型类后继续本章的其余内容，或者大致了解该部分后直接向下阅读。

## 派生

### 派生与自动派生

派生使用`deriving`关键字，其声明应当跟随类型的定义。

对于 ***普通(stock)*** 类型类（`Eq`、`Ord`、`Enum`、`Ix`、`Bounded`、`Read`和`Show`），Haskell允许用户使用自动派生出这些类型类的有关实例。如前面我们在定义`Figure''`和`SolidFigure`时就自动派生了`Show`类型类。


### 默认实现的派生

有时我们希望自定义的类型类能够类似普通类型类一样可以自动派生出实例，这可以通过在类型类定义中添加默认的实现来实现。

我们修改`Judgeable`类型类为带有默认实现的版本`Judgeable'`。

```hs
-- code4.hs
class Judgeable' a where 
  judgeType' :: a -> String 
  judgeType' x = "A Default Judgeable Type"
  tellShape' :: a -> String 
  tellShape' x = "A Default Judgeable Shape"
```

一般地，我们可以使用空的`instance`声明来生成`Judgeable'`关于`SolidFigure`的实例。

```hs
-- code4.hs
instance Judgeable' SolidFigure
```

或者，我们可以使用`{-# LANGUAGE DeriveAnyClass #-}`扩展，这将允许我们像自动派生普通类型类一样派生带有默认实现的类型类，这里定义`SolidFigure'`作为`SolidFigure`的副本来展示这一用法。

```hs
-- code4.hs
{-# LANGUAGE DeriveAnyClass #-}

data SolidFigure' = 
  Sphere' {getDiameter :: Diameter}
    | Cuboid' {getLength :: Length, getWidth :: Width, getHeight :: Height}
    | Cylinder' {getDiameter :: Diameter, getHeight :: Height}
  deriving (Show,Judgeable')
```

尝试使用`Judgeable'`类型类中的函数：

```bash
Prelude> tellShapeInfo' x = "This is " ++ tellShape' x ++ " which is " ++ judgeType' x
Prelude> tellShapeInfo' (Sphere 1)
"This is A Default Judgeable Shape which is A Default Judgeable Type"
```

### 新类型的派生

在前面章节我们提到了`newtype`定义新类型的方法，并简述了其在构造方面的限制和为编译器带来的优势。

在编译器层面上，使用`newtype`声明的新类型与原类型是不被区分的，当原类型已经在特定类型类中实现了实例，我们很有可能需要新类型上也有同样的实现。Haskell提供了`{-# LANGUAGE GeneralizedNewtypeDeriving #-}`扩展以便导出类型类。

```hs
-- code4.hs
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE DerivingStrategies #-}

newtype Fig = Fig SolidFigure deriving newtype (Judgeable)
```

> 提示：这里另外使用了`{-# LANGUAGE DerivingStrategies #-}`扩展，并在`deriving`后添加`newtype`关键字，其原因是为了消除来自DerivingAnyClass扩展的冲突，在仅使用新类型派生扩展时只需按照通常派生的写法即可。有关DerivingStrategies的内容将在下文讲解。

```bash
Prelude> tellShapeInfo x = "This is " ++ tellShape x ++ " which is " ++ judgeType x
Prelude> tellShapeInfo (Fig (Sphere 1))
"This is A Sphere which is A SolidFigure"
```

### 派生策略

派生策略扩展`{-# LANGUAGE DerivingStrategies #-}`用于消除来自DeiriveAnyClass和Generalized NewtypeDeriving以及内置导出之间的冲突。例如对一个新类型派生实例，到底是按照类型类中默认实现去派生还是参照与之同构的原类型派生。

使用派生策略扩展后，通过使用三个新的关键字跟随`deriving`对派生方式进行区分,它们分别为`stock`,`newtype`和`anyclass`。其中`stock`用于对于普通类型类（即`Eq`、`Ord`、`Enum`、`Ix`、`Bounded`、`Read`和`Show`）的派生；`newtype`用于对新类型的派生；`anyclass`用于含有默认实现的自定义类型类的派生。

> 补充: Haskell 提供了一些扩展用于自动派生其他内置的类型类，这些扩展分别为 DeriveGeneric,DeriveFunctor,DeriveDataTypeable,DeriveFoldable,DeriveTraversable,DeriveLift，启用扩展后可以就使用`stock`关键字对相应的类型类进行派生。另外，这些扩展已经包含在新的标准中`ghc 2021`中，无需手动开启扩展。

> 提示：上述各种扩展对应的类型类会在本章后续讲解

### 孤立派生

通常情况下，deriving 导出实例必须跟随类型的定义声明的，但在实际场景中，我们很难保证后期不添加新的派生，这将导致对原代码的修改，破坏了工程中的开闭原则。使用`{-# LANGUAGE StandaloneDeriving #-}`扩展，可以声明孤立的派生，使得派生与类型定义分离。

```hs
-- code4.hs
{-# LANGUAGE StandaloneDeriving #-}

deriving instance Eq Figure''
deriving instance Eq SolidFigure
deriving instance Eq SolidFigure'
```

这里为之前声明的三个类型另外派生`Eq`实例，这样就可以对每种类型中的值进行比较：

```bash
Prelude> Circle'' 1 == Circle'' 1
True
Prelude> Sphere 1 /= Cuboid 1 2 3
True
Prelude> Sphere' 2 == Cuboid' 3 4 5
False
```

## 特殊用法

### 多参数类型类

通常，类型类的声明只能包含一个参数，或者说一个类型类的实例只能属于一个类型。通过使用扩展`{-# LANGUAGE MultiParamTypeClasses #-}`允许类型类突破这一限制。

`Figure''`和`SolidFigure`属于不同类型，即使我们派生出两个类型的`Eq`实例，也是无法进行两个类型之间值的比较的。使用多参数类型类扩展，可以定义一个新的类型类达到此效果。

```hs
-- code4.hs
{-# LANGUAGE MultiParamTypeClasses #-}

class Same a b where
  same :: a -> b -> Bool 
  same _ _ = False

instance Same Figure'' SolidFigure  

instance Same SolidFigure Figure'' 

instance Same SolidFigure SolidFigure where 
  same = (==) 

instance Same Figure'' Figure'' where 
  same = (==)
```

我们定义了一个`Same`类型类，内部含有一个函数`same`用于判断两个值是否相等，默认情况下是不相等的，因此对于两个不同的类型，直接使用空`instance`声明实例。对于两个相同的类型，`same`函数作用与`(==)`函数相同。

```bash
Prelude> same (Circle'' 1) (Sphere 1)
False
Prelude> same (Sphere 1) (Circle'' 1)
False
Prelude> same (Sphere 1) (Sphere 1)
True
```

### 无参数类型类

无参数类型类需要扩展`{-# LANGUAGE NullaryTypeClasses #-}`，但目前该扩展已经被遗弃，该扩展的功能被包含到MultiParamTypeClasses中。无参数类型类可用于记录类型签名中的某些假设或添加一些全局可配置的设置在程序中[[2]](#ref2)。

```hs
-- code4.hs

class DefaultVal where 
  unit :: Double
  unit = 1
  info :: String 
  info = "global information"
  needinstantiation :: ()
```

显然，无参数类型类由于没有参数，无法为特定类型声明实例，因此至多为其声明一个实例。

```hs
-- code4.hs

instance DefaultVal where
  needinstantiation = ()
```

### 灵活的实例声明

当我们需要声明具有多态类型的类型类实例时，其与通常的声明方法无异。但对于嵌套的类型（即多态类型中参数实例化，如`[Char]`或`Maybe Int`等）需要使用灵活的实例声明扩展`{-# LANGUAGE FlexibleInstances #-}`进行类型类实例的声明。

```hs
-- code4.hs
{-# LANGUAGE FlexibleInstances #-}

class Empty a where 
  isEmpty :: a -> Bool

-- ordinary instance 
instance Empty (Maybe a) where 
  isEmpty Nothing = True 
  isEmpty (Just _) = False 

-- flexible instance
instance Empty [Char] where 
  isEmpty [] = True
  isEmpty (x:xs) = False
```

上述示例定义了一个类型类用于判断容器是否为空，第一个实例声明的类型是多态类型`Maybe a`，因此直接声明即可；第二个实例声明的类型是`[Char]`，列表`[a]`中的`a`实例化为了`Char`，因此需要使用灵活实例声明扩展才可以。

### 函数依赖

函数依赖通常用来限制类型类的参数，尤其是对于多参数类型类中参数之间的决定关系[[3]](#ref3)。这种决定关系（或者说映射），使得其中的某些参数取决于另一些参数，例如对于`a -> b`这种关系，当`a`确定时,`b`有唯一的类型与之对应。

考虑不使用函数依赖的情况：

```hs
-- code4.hs
{-# LANGUAGE FunctionalDependencies #-}

class WithoutDep a b c where 
  func :: a -> b -> c 

instance WithoutDep Int Int Int where 
  func = \ x y -> 0

instance WithoutDep Int Int Double where
  func = \ x y -> 0
```

可以看到`WithoutDep`类型类中类型参数没有依赖关系，因而可以声明`WithoutDep Int Int Int`和`WithoutDep Int Int Double`两个实例。
在实际使用中，当我们尝试使用`func`函数时，程序会困惑应当使用哪个实例中的函数，除非我们手动给出返回类型。

> 提示： 即使只声明一个实例，程序仍然无法计算出结果，直到我们给出返回类型，因此这种歧义产生的原因并不是多个实例的导致的，而是无法进行类型推断

```bash
Prelude> func 1 2
<interactive>:1:1: error:
    • Could not deduce (WithoutDep a0 b0 c)
      from the context: (WithoutDep a b c, Num a, Num b)
        bound by the inferred type for ‘it’:
                   forall a b c. (WithoutDep a b c, Num a, Num b) => c
        at <interactive>:1:1-8
      The type variables ‘a0’, ‘b0’ are ambiguous
    • In the ambiguity check for the inferred type for ‘it’
      To defer the ambiguity check to use sites, enable AllowAmbiguousTypes
      When checking the inferred type
        it :: forall a b c. (WithoutDep a b c, Num a, Num b) => c
Prelude> (func (1 :: Int) (2 :: Int)) :: Int 
0
Prelude> (func (1 :: Int) (2 :: Int)) :: Double
0.0
```

上述方法在一些情况下可能会作为有用的技巧，例如我们希望一个函数在接受相同的输入时，会根据我们的需要（显示给出返回类型）返回不同的结果。然而我们知道，当类型之间存在依赖关系时，或者说只需要声明一个实例时，程序仍然需要显式给出返回类型，这显然带来了不小的麻烦。

通过使用函数依赖，可以帮助程序直接推断出返回类型：

```hs
class WithDep a b c | a b -> c where 
  func' :: a -> b -> c

instance WithDep Int Int Int where 
  func' = \ x y -> 0

{-
-- illegal because a definition has already existed.
instance WithDep Int Int Double where 
  func' = \ x y -> 0
-}
```

在`WithDep`类型类中，第三个参数受到前两个参数的限制，因此只能声明一个`WithDep Int Int Int`实例，`WithDep Int Int Double`实例与函数依赖的唯一性不符，因而是非法的。

```bash
Prelude> func' (1 :: Int) (2 :: Int)) 
0
```

可见，使用函数依赖后，返回类型`c`被自动推断成了`Int`，而无需我们手动指定。


### 别名的实例导出

一般地，我们无法为类型的别名声明类型类实例。但使用特别的扩展`{-# LANGUAGE TypeSynonymInstances #-}`可以允许这一点。

```hs
-- code4.hs
{-# LANGUAGE TypeSynonymInstances #-}

type SynFig = Fig 

instance Judgeable' SynFig  
```

例如，我们声明了上一节中`Fig`类型的一个别名`SynFig`,其已经派生了`Judgeable`类型类的实例，因此我们实现其别名的`Judgeable'`类型类的实例。

```bash
Prelude> tellShapeInfo' x = "This is " ++ tellShape' x ++ " which is " ++ judgeType' x 
Prelude> tellShapeInfo' (Fig (Sphere 1))
"This is A Default Judgeable Shape which is A Default Judgeable Type"
```

### 存在类型

### 关联类型族

关联类型族是类型层面上的函数，其功能与函数依赖类似，能够消除


















<p id="ref1">[1] Polymorphism. (2015, January 21). HaskellWiki, . Retrieved 02:37, April 10, 2024 from https://wiki.haskell.org/index.php?title=Polymorphism&oldid=59216.</p>
<p id="ref2">[2] Language options. Glasgow Haskell Compiler 8.6.5 User's Guide. Retrieved 10:06, April 13, 2024 from https://downloads.haskell.org/~ghc/8.6.5/docs/html/users_guide/glasgow_exts.html#nullary-type-classes</p>
<p id="ref3">[3] Functional dependencies. (2021, July 21). HaskellWiki, . Retrieved 03:35, April 13, 2024 from https://wiki.haskell.org/index.php?title=Functional_dependencies&oldid=64590.</p>