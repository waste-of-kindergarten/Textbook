# 错误和异常专题

在Haskell的使用中，离不开对错误(**Error**)和异常(**Exception**)的处理，但两者应当被谨慎对待和区分。具体来说，异常应当是运行时预料之中但不规则的情况；而错误则是运行程序中的失误，这些失误只能靠调试和修复程序来解决[[1]](#ref1)。一个异常可以是“超出磁盘空间”、“读取受保护的文件”，“在读取文件时移除磁盘”等[[2]](#ref2);而一个错误则是必须由程序员来修复的问题，除了程序员外别无其他修复的方法。

例如，一个常见的异常是`divide by zero`,当我们尝试在ghci中将整除的除数设为0时，会触发这个异常：

```bash
Prelude> 1 `div` 0
*** Exception: divide by zero
```

在Haskell中，错误几乎和未定义(`undefined`)是同义词，或者说错误是`undefined`的语法糖[[1]](#ref1),因此：

```bash
Prelude> undefined
*** Exception: Prelude.undefined
CallStack (from HasCallStack):
  error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err
  undefined, called at <interactive>:5:7 in interactive:Ghci1
```

> 至于为什么上面同时出现了Exception还有Error,我们将在后面解释，这是CallStack的作用

## 错误处理

当我们需要手动处理错误时，我们可以使用`error`函数，但这只是一种语法糖函数，其本质仍然是`undefined`。

```hs
main = error "undefined"
-- main = undefined 
```

```bash
$ runghc main.hs
main.hs: undefined
CallStack (from HasCallStack):
  error, called at test.hs:1:8 in main:Main
```


## 异常处理

### “纯”异常

我们可以通过特定的数据类型对纯的异常进行处理。

一个自然的想法就是使用`Maybe`表示异常，在未发生异常时，使用`Just`返回结果；而在发生异常时用`Nothing`将异常抛出。

例如我们取一个列表的头部`head`，这个操作不能应用在空列表上，否则：

```bash
Prelude> head []
*** Exception: Prelude.head: empty list
```










------------------------------------------

<p id="ref1">[1] Error vs. Exception. (2019, July 23). HaskellWiki. Retrieved 19:56, January 21, 2025 from https://wiki.haskell.org/index.php?title=Error_vs._Exception&oldid=62969.</p>
<p id="ref1">[1] Exception. (2020, January 22). HaskellWiki. Retrieved 20:11, January 21, 2025 from https://wiki.haskell.org/index.php?title=Exception&oldid=63187.</p>