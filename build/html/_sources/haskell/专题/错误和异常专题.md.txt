# 错误和异常专题

在Haskell的使用中，离不开对错误(**Error**)和异常(**Exception**)的处理，但两者应当被谨慎对待和区分。具体来说，异常应当是运行时预料之中但不规则的情况；而错误则是运行程序中的失误，这些失误只能靠调试和修复程序来解决[[1]](#ref1)。一个异常可以是“超出磁盘空间”、“读取受保护的文件”，“在读取文件时移除磁盘”等[[2]](#ref2);而一个错误则是必须由程序员来修复的问题，除了程序员外别无其他修复的方法。

例如，一个常见的异常是`divide by zero`,当我们尝试在ghci中将整除的除数设为0时，会触发这个异常：

```bash
Prelude> 1 `div` 0
*** Exception: divide by zero
```

在Haskell中，错误几乎和未定义(`undefined`)是同义词，或者说错误是`undefined`的语法糖[[1]](#ref1),因此：

```bash
Prelude> undefined
*** Exception: Prelude.undefined
CallStack (from HasCallStack):
  error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err
  undefined, called at <interactive>:5:7 in interactive:Ghci1
```

> 至于为什么上面同时出现了Exception还有Error,我们将在后面解释，这是CallStack的作用

## 错误处理

当我们需要手动处理错误时，我们可以使用`error`函数，但这只是一种语法糖函数，其本质仍然是`undefined`。

```hs
main = error "undefined"
-- main = undefined 
```

```bash
$ runghc main.hs
main.hs: undefined
CallStack (from HasCallStack):
  error, called at test.hs:1:8 in main:Main
```


## 异常处理

### “纯”异常

我们可以通过特定的数据类型来应对纯代码中的异常，使其仍然不涉及任何副作用。

一个自然的想法就是使用`Maybe`表示异常，在未发生异常时，使用`Just`返回结果；而在发生异常时用`Nothing`将异常抛出。

例如取列表头部操作`head`不能处理空列表的情形，我们可以使用`Maybe`数据类型构造一个“安全”的函数`safeHead`:

```hs
-- code'7.hs
safeHead :: [a] -> Maybe a
safeHead [] = Nothing
safeHead (x:_) = Just x
```

除了`Maybe`我们还可以使用表现力更强的`Either`类型,`Either`类型在抛出异常时还会添加相应的异常信息。

```hs
-- code'7.hs
safeHead' :: [a] -> Either String a 
safeHead' [] = Left "Cannot cope with emptyList"
safeHead' (x:_) = Right x
```

在`mtl`包中`Control.Monad.Except`已经内置了基于Either的异常类型`Except`类型，其定义类似：

```hs
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
newtype Except e a = Except (Either e a) 
  deriving (Functor,Applicative,Monad,Show)
```

在连续的函数操作中，我们可以使用其Monad的特性来抛出其中的异常。

```hs
-- code'7.hs
safeTail :: [a] -> Except String [a]
safeTail [] = Except $ Left "Cannot extract a tail from an empty list"
safeTail (_:xs) = return xs

safeDrop3 :: [a] -> Except String [a]
safeDrop3 xs = do 
  xsdrop1 <- safeTail xs
  xsdrop2 <- safeTail xsdrop1
  safeTail xsdrop2
```

我们定义`safeTail`函数作为`tail`的安全版本，当遇到空列表时抛出异常；`safeDrop3`函数连续使用了三次`safeTail`以便丢弃列表的前三个元素，当列表元素少于三个时就会抛出异常。

```bash
Prelude> :l "code'7.hs"
[1 of 1] Compiling Main             ( code'7.hs, interpreted )
Ok, one module loaded.
Prelude> safeDrop3 [1,2,3]
Except (Right [])
Prelude> safeDrop3 [1,2]
safeDrop3 [1,2]
Except (Left "Cannot extract a tail from an empty list")
```

> 注意： 实际上`Control.Monad.Except`中的`Except`类型仅仅是`ExceptT`转换器的一个实例的别名.
> ```
> newtype ExceptT e (m :: * -> *) a = ExceptT (m (Either e a))
> type Except e = ExceptT e Data.Functor.Identity.Identity :: * -> *
> ```

异常的抛出往往与异常的捕获联合使用，当有异常抛出时执行某个处理函数回到正常的执行中；否则保持上一个动作结束时的状态。

```hs
-- code'7.hs
capture :: Except e a -> (e -> Except e a) -> Except e a 
capture ex@(Except e) = case e of 
  Right t ->  const ex 
  Left e' -> \f -> f e'
```

例如我们希望丢弃列表前三个元素，如果失败了则反转列表。

```hs
-- code'7.hs
safeDrop3OrRev :: [a] -> Except String [a]
safeDrop3OrRev xs = capture (safeDrop3 xs) (\_ -> return $ reverse xs)
```

```bash
Prelude> safeDrop3OrRev [1,2,3]
Except (Right [])
Prelude> safeDrop3OrRev [1,2,3,4]
Except (Right [4])
Prelude> safeDrop3OrRev [1,2]
Except (Right [2,1])
```

在`Control.Monad.Except`中，已经封装了异常的抛出和捕获到`MonadError`类型类中，其定义如下：

```hs
class Monad m => MonadError e m | m -> e where 
  throwError :: e -> m a 
  catchError :: m a -> (e -> m a) -> m a
  {-# MINIMAL throwError, catchError #-}
```

其中`throwError`为抛出异常函数；而`catchError`为捕获异常函数，其第一个参数中可以包含异常抛出（即`throwError`），而第二个参数则是用来恢复异常的函数。

> 注意： 最好不要使用`fail`来抛出异常，一方面在旧版本中，部分`fail`函数使用`error`来定义（这导致了中断）；另一方面`fail`函数本身的意义是用来在`do-notation`中`<-`左侧匹配失败后进行调用，而不是针对用户的异常抛出

















------------------------------------------

<p id="ref1">[1] Error vs. Exception. (2019, July 23). HaskellWiki. Retrieved 19:56, January 21, 2025 from https://wiki.haskell.org/index.php?title=Error_vs._Exception&oldid=62969.</p>
<p id="ref1">[1] Exception. (2020, January 22). HaskellWiki. Retrieved 20:11, January 21, 2025 from https://wiki.haskell.org/index.php?title=Exception&oldid=63187.</p>