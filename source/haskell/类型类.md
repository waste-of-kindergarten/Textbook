# 类型类

在 *数据类型与函数* 一章中，我们阐述了多态性分为 ***参数多态性(Parametric PolyMorphism)*** 和 ***临时多态性(Ad-hoc PolyMorphism)*** ， 并着重讨论了参数多态性。本章我们讲解的类型类，是一种允许使用临时多态性的语法。

临时多态性允许某个变量为若干类型中的任意一种，这是因为它对于每种类型都进行了单独的定义[[1]](#ref1)。

> 提示：与参数多态性明显不同的是，参数多态性中类型的变量指任意类型，而临时多态性的类型并不是任意的。

## 类型类的声明

仍然沿用`Figure''`类型，并定义一个`SolidFigure`类型表示立体图形。

```hs
-- code4.hs
{-# LANGUAGE DuplicateRecordFields #-}
-- 开启扩展 DuplicateRecordFields 允许记录语法中的域名称重复
type Height = Double

data SolidFigure = 
    Sphere {getDiameter :: Diameter}
    | Cuboid {getLength :: Length, getWidth :: Width, getHeight :: Height}
    | Cylinder {getDiameter :: Diameter, getHeight :: Height}
    deriving (Show)
```

`SolidFigure`类型定义了三个立体图形，`Sphere`表示球体，`Cuboid`为长方体，`Cylinder`为圆柱体，当然还有其他立体图形，读者可以根据自己的喜好自行添加。

在前面章节中我们定义过的`judgeShape`函数，它可以用于判断`Figure''`类型的形状，我们希望定义一个更通用的函数，它既可以判断平面图形`Figure''`也可以判断立体图形`SolidFigure`。类型类恰好就可以胜任这种情形。

我们定义一个`Judgeable`类型类用来表示图形是可判断的，如下：

```hs
-- code4.hs
class Judgeable a where 
    judgeType :: a -> String
    tellShape :: a -> String
```

类型类以`class`关键字开头，并定义了两个函数`judgeType`和`tellShape`用于判断图形的类型和图形的形状。

此时，我们已经构建了具有临时多态性的函数，接下来只需要分别对两种待处理的类型进行实例化。

```hs
-- code4.hs
-- {-# LANGUAGE InstanceSigs #-}

instance Judgeable Figure'' where  
    -- judgeType :: Figure'' -> String
    judgeType _ = "A Figure"
    -- tellShape :: Figure'' -> String
    tellShape (Circle'' _) = "A Circle"
    tellShape (Rectangle'' {}) = "A Rectangle"
    tellShape (Triangle'' {}) = "A Triangle"

instance Judgeable SolidFigure where 
    -- judgeType :: SolidFigure -> String
    judgeType _ = "A SolidFigure"
    -- tellShape :: SolidFigure -> String
    tellShape (Sphere _) = "A Sphere"
    tellShape (Cuboid {}) = "A Cuboid"
    tellShape (Cylinder {}) = "A Cylinder"
```

使用关键字`instance`将类型类`Judgeable`中参数`a`实例化为对应类型，并为实例定义相应的函数。

> 注意：在Haskell 2010标准中，类型类实例中默认不允许使用类型签名，可以使用扩展 `{-# LANGUAGE InstanceSigs #-}`允许这一点，这在后续的标准中已经被移除

下面尝试在GHCi中使用这个类型类：

```bash
Prelude> :load code4.hs
[1 of 1] Compiling Main             ( code4.hs, interpreted )
Ok, one module loaded.
Prelude> tellShapeInfo x = "This is " ++ tellShape x ++ " which is " ++ judgeType x
Prelude> tellShapeInfo (Sphere 1)
"This is A Sphere which is A SolidFigure"
Prelude> tellShapeInfo (Circle'' 1)
"This is A Circle which is A Figure"
```

## 常用类型类

Haskell中内置了众多的类型类，由于这些类型类可以自动派生出实例，本小结仅对这些类型类进行简要的介绍。对于希望了解手动定义的读者可以在本章末尾查看有关常用类型类实现的示例。

### 相等类型类 `Eq`

`Eq`类型类提供了判断相等（不等）的函数，其定义如下：

```hs
class Eq a where
  (==) :: a -> a -> Bool
  (/=) :: a -> a -> Bool
  {-# MINIMAL (==) | (/=) #-} 
```

`Eq`类型类中`(==)`函数用于判断相等，而`(/=)`用于判断不等。根据尾行的提示，在对类型类进行实例化时，只需要实现`(==)`和`(/=)`中的一个即可（最小实现）。

### 有序类型类 `Ord`

`Ord`类型类用于实现排序相关的函数，一个能够排序的类型必然是能够判断相等的（或者说受到相等性约束），因此在实现`Ord`类型类实例时，必须首先实现`Eq`的实例。

```hs
class Eq a => Ord a where
  compare :: a -> a -> Ordering
  (<) :: a -> a -> Bool
  (<=) :: a -> a -> Bool
  (>) :: a -> a -> Bool
  (>=) :: a -> a -> Bool
  max :: a -> a -> a
  min :: a -> a -> a
  {-# MINIMAL compare | (<=) #-}
```

`Ord`类型类中内置了许多函数，但根据尾行提示，只需要实现`compare`函数或者`(<=)`函数即可，其他函数可以根据用户实现的函数和`Eq`类型类的约束导出。

### 有界类型类 `Bounded`

有界类型类比较简单，用于为类型提供一个最小值和最大值。

```hs
class Bounded a where
  minBound :: a
  maxBound :: a
  {-# MINIMAL minBound, maxBound #-}
```

`Bounded`类型类的实例需要对两个函数全部实现。

### 枚举类型类 `Enum`

`Enum`类型类定义如下：

```hs
class Enum a where
  succ :: a -> a
  pred :: a -> a
  toEnum :: Int -> a
  fromEnum :: a -> Int
  enumFrom :: a -> [a]
  enumFromThen :: a -> a -> [a]
  enumFromTo :: a -> a -> [a]
  enumFromThenTo :: a -> a -> a -> [a]
  {-# MINIMAL toEnum, fromEnum #-}
```

一般地，只需要定义`toEnum`和`fromEnum`即可实现枚举类型的实例，这两个函数将实例中实现的类型与整数做了一一对应。

> 提示： 前面使用过的语法糖`..`(如`[1..5]`表示`[1,2,3,4,5]`)就是依靠`Enum`类型类实现的，只要一个类型被实现为`Enum`的实例，就可以使用`..`生成一个枚举列表。

### 索引类型类 `Ix`

`Ix`类型类为离散有序的类型提供索引，定义如下：

```hs
class Ord a => Ix a where
  range :: (a, a) -> [a]
  index :: (a, a) -> a -> Int
  GHC.Arr.unsafeIndex :: (a, a) -> a -> Int
  inRange :: (a, a) -> a -> Bool
  rangeSize :: (a, a) -> Int
  GHC.Arr.unsafeRangeSize :: (a, a) -> Int
  {-# MINIMAL range, (index | unsafeIndex), inRange #-}
```

`Ix`类型类的最小实现为`range`，`index`和`unsafeIndex`之一，以及`inRange`函数。其中`range`函数接受一个二元组（左边应当小于右边），并返回一个以元组元素为范围列表（包含元组中的两个元素）；`index`函数用于检索某个元素位于元组标示的范围的位置,当检索元素不再范围内时会报错； `unsafeIndex`是`index`不会报错的版本，但无法保证元素是否在范围内；`inRange`则判断元素是否在范围内。其余函数根据名称和类型签名也不难判断其含义。

### 可显示类型类 `Show`

在Haskell中，不是所有类型“天生”就可以输出到终端上的，这需要通过实现`Show`类型类的实例来完成。

```hs
class Show a where
  showsPrec :: Int -> a -> ShowS
  show :: a -> String
  showList :: [a] -> ShowS
  {-# MINIMAL showsPrec | show #-}
```

为了能够显示某个类型的值，可以选择实现`show`函数或者`showsPrec`函数，其中`showsPrec`函数返回的类型`ShowS`实际上是`String -> String`的别名。

### 可读类型类 `Read`

`Read`类型类与`Show`类型类可以认为是互为相反的操作，其将字符串转换为特定类型的值。

```hs
class Read a where
  readsPrec :: Int -> ReadS a
  readList :: ReadS [a]
  GHC.Read.readPrec :: Text.ParserCombinators.ReadPrec.ReadPrec a
  GHC.Read.readListPrec :: Text.ParserCombinators.ReadPrec.ReadPrec
                             [a]
  {-# MINIMAL readsPrec | readPrec #-}
```

这里只介绍一个常用的必要实现函数`readsPrec`，其接受的`Int`参数为构造器的优先级（函数应用的优先级为10），返回类型中的`ReadS a`是`String -> [(a,String)]`的别称。

### 字符串类型类 `IsString`

`IsString`类型类位于`Data.String`模块。在实际编程中，默认的字符串String类型某些操作效率不高（单向链表），因此Haskell还提供了诸如ByteString、Text等类型，因此有时需要将String与其他存储字符串的类型进行转换，这是就需要用到`IsString`类型类。

> 补充： ByteString通过Word8数组存储字符串，Text将ByteString编码为如ASCII,UTF8等标准格式。

```hs
class IsString a where
  fromString :: String -> a
  {-# MINIMAL fromString #-}
```

> 提示： 一般情况下，可以使用`{-# LANGUAGE OverloadedStrings #-}`让不同“字符串”之间进行转换。


### 函子类型类 (`Functor`, `Applicative`, `Monad`)

三种函子类型类虽然是常见的类型类，但其比较复杂（涉及到范畴相关的知识），因此我们将其单独书写为一章<a>函子教程专题</a>,读者可以选择详细了解三种函子类型类后继续本章的其余内容，或者大致了解该部分后直接向下阅读。

## 派生

### 自动派生

对于 ***普通(stock)*** 类型类（`Eq`、`Ord`、`Enum`、`Ix`、`Bounded`、`Read`和`Show`），Haskell允许用户使用自动派生出这些类型类的有关实例。如前面我们在定义`Figure''`和`SolidFigure`时就自动派生了`Show`类型类。

自动派生使用`deriving`关键字，其声明应当跟随类型的定义。

### 默认实现的派生

有时我们希望自定义的类型类能够类似普通类型类一样可以自动派生出实例，这可以通过在类型类定义中添加默认的实现来实现。

我们修改`Judgeable`类型类为带有默认实现的版本`Judgeable'`。

```hs
-- code4.hs
class Judgeable' a where 
  judgeType' :: a -> String 
  judgeType' x = "A Default Judgeable Type"
  tellShape' :: a -> String 
  tellShape' x = "A Default Judgeable Shape"
```

一般地，我们可以使用空的`instance`声明来生成`Judgeable'`关于`SolidFigure`的实例。

```hs
-- code4.hs
instance Judgeable' SolidFigure
```

或者，我们可以使用`{-# LANGUAGE DeriveAnyClass #-}`扩展，这将允许我们像自动派生普通类型类一样派生带有默认实现的类型类，这里定义`SolidFigure'`作为`SolidFigure`的副本来展示这一用法。

```hs
-- code4.hs
{-# LANGUAGE DeriveAnyClass #-}

data SolidFigure' = 
  Sphere' {getDiameter :: Diameter}
    | Cuboid' {getLength :: Length, getWidth :: Width, getHeight :: Height}
    | Cylinder' {getDiameter :: Diameter, getHeight :: Height}
  deriving (Show,Judgeable')
```

尝试使用`Judgeable'`类型类中的函数：

```bash
Prelude> tellShapeInfo' x = "This is " ++ tellShape' x ++ " which is " ++ judgeType' x
Prelude> tellShapeInfo' (Sphere 1)
"This is A Default Judgeable Shape which is A Default Judgeable Type"
```

### 新类型的派生

在前面章节我们提到了`newtype`定义新类型的方法，并简述了其在构造方面的限制和为编译器带来的优势。

















<p id="ref1">[1] Polymorphism. (2015, January 21). HaskellWiki, . Retrieved 02:37, April 10, 2024 from https://wiki.haskell.org/index.php?title=Polymorphism&oldid=59216.</p>